#!/usr/bin/env bun
// @bun

// src/cli.ts
import { parseArgs } from "util";

// src/git-manager.ts
class GitManager {
  async getCurrentBranch() {
    const result = await Bun.$`git rev-parse --abbrev-ref HEAD`.text();
    return result.trim();
  }
  async isGitRepo() {
    try {
      await Bun.$`git rev-parse --git-dir`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async getStatus() {
    const currentBranch = await this.getCurrentBranch();
    const statusResult = await Bun.$`git status --porcelain`.text();
    const isClean = statusResult.trim() === "";
    let ahead = 0;
    let behind = 0;
    try {
      const aheadResult = await Bun.$`git rev-list --count HEAD..origin/${currentBranch}`.text();
      behind = parseInt(aheadResult.trim()) || 0;
      const behindResult = await Bun.$`git rev-list --count origin/${currentBranch}..HEAD`.text();
      ahead = parseInt(behindResult.trim()) || 0;
    } catch {}
    return {
      currentBranch,
      isClean,
      ahead,
      behind
    };
  }
  async getCommitsSince(baseBranch) {
    try {
      const result = await Bun.$`git log ${baseBranch}..HEAD '--pretty=format:%H|%s|%an|%ad' --date=iso`.text();
      if (!result.trim()) {
        return [];
      }
      return result.trim().split(`
`).map((line) => {
        const [hash, message, author, date] = line.split("|");
        return { hash, message, author, date };
      });
    } catch (error) {
      console.error(`Git command failed for ${baseBranch}:`);
      console.error(error);
      throw new Error(`Failed to get commits since ${baseBranch}: ${error}`);
    }
  }
  async fetchOrigin() {
    try {
      await Bun.$`git fetch origin`;
    } catch (error) {
      throw new Error(`Failed to fetch from origin: ${error}`);
    }
  }
  async rebaseOnto(targetBranch) {
    try {
      await Bun.$`git rebase origin/${targetBranch}`;
    } catch (error) {
      try {
        await Bun.$`git rebase --abort`;
      } catch {}
      throw new Error(`Failed to rebase onto ${targetBranch}. Please resolve conflicts manually.`);
    }
  }
  async createBranch(branchName, fromCommit) {
    try {
      if (fromCommit) {
        await Bun.$`git checkout -b ${branchName} ${fromCommit}`;
      } else {
        await Bun.$`git checkout -b ${branchName}`;
      }
    } catch (error) {
      throw new Error(`Failed to create branch ${branchName}: ${error}`);
    }
  }
  async checkoutBranch(branchName) {
    try {
      await Bun.$`git checkout ${branchName}`;
    } catch (error) {
      throw new Error(`Failed to checkout branch ${branchName}: ${error}`);
    }
  }
  async branchExists(branchName) {
    try {
      await Bun.$`git rev-parse --verify ${branchName}`;
      return true;
    } catch {
      return false;
    }
  }
  async pushBranch(branchName, force = false) {
    try {
      const forceFlag = force ? "--force-with-lease" : "";
      if (force) {
        await Bun.$`git push origin ${branchName} --force-with-lease`;
      } else {
        await Bun.$`git push origin ${branchName}`;
      }
    } catch (error) {
      throw new Error(`Failed to push branch ${branchName}: ${error}`);
    }
  }
  async getRemoteUrl() {
    try {
      const result = await Bun.$`git remote get-url origin`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get remote URL: ${error}`);
    }
  }
  async getCommitHash(ref) {
    try {
      const result = await Bun.$`git rev-parse ${ref}`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get commit hash for ${ref}: ${error}`);
    }
  }
  async getCommitMessage(hash) {
    try {
      const result = await Bun.$`git log -1 --pretty=format:"%s" ${hash}`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get commit message for ${hash}: ${error}`);
    }
  }
  async getSyncStatus(remoteBranch) {
    try {
      await this.fetchOrigin();
      const remoteRef = `origin/${remoteBranch}`;
      try {
        await Bun.$`git rev-parse --verify ${remoteRef}`.quiet();
      } catch {
        return {
          status: "clean",
          aheadCount: 0,
          behindCount: 0,
          localCommits: [],
          remoteCommits: []
        };
      }
      const aheadResult = await Bun.$`git rev-list --count ${remoteRef}..HEAD`.text();
      const aheadCount = parseInt(aheadResult.trim()) || 0;
      const behindResult = await Bun.$`git rev-list --count HEAD..${remoteRef}`.text();
      const behindCount = parseInt(behindResult.trim()) || 0;
      let localCommits = [];
      let remoteCommits = [];
      if (aheadCount > 0) {
        const localResult = await Bun.$`git rev-list ${remoteRef}..HEAD`.text();
        localCommits = localResult.trim().split(`
`).filter(Boolean);
      }
      if (behindCount > 0) {
        const remoteResult = await Bun.$`git rev-list HEAD..${remoteRef}`.text();
        remoteCommits = remoteResult.trim().split(`
`).filter(Boolean);
      }
      let status;
      if (aheadCount === 0 && behindCount === 0) {
        status = "clean";
      } else if (aheadCount > 0 && behindCount === 0) {
        status = "ahead";
      } else if (aheadCount === 0 && behindCount > 0) {
        status = "behind";
      } else {
        status = "diverged";
      }
      return {
        status,
        aheadCount,
        behindCount,
        localCommits,
        remoteCommits
      };
    } catch (error) {
      throw new Error(`Failed to check sync status with ${remoteBranch}: ${error}`);
    }
  }
  async detectDuplicateCommits(remoteBranch) {
    try {
      const remoteRef = `origin/${remoteBranch}`;
      const localResult = await Bun.$`git log ${remoteRef}..HEAD --pretty=format:"%s"`.text();
      const localMessages = localResult.trim().split(`
`).filter(Boolean);
      if (localMessages.length === 0) {
        return { hasDuplicates: false, duplicateMessages: [] };
      }
      const remoteResult = await Bun.$`git log ${remoteRef} --pretty=format:"%s" -20`.text();
      const recentRemoteMessages = remoteResult.trim().split(`
`).filter(Boolean);
      const duplicates = localMessages.filter((msg) => recentRemoteMessages.some((remoteMsg) => remoteMsg.trim() === msg.trim()));
      return {
        hasDuplicates: duplicates.length > 0,
        duplicateMessages: duplicates
      };
    } catch (error) {
      throw new Error(`Failed to detect duplicate commits: ${error}`);
    }
  }
  generateBranchName(commits, userPrefix, strategy) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
    switch (strategy) {
      case "timestamp":
        return `${userPrefix}/${timestamp}`;
      case "sequential":
        return `${userPrefix}/stack-${Date.now()}`;
      case "commit-message":
      default:
        if (commits.length === 0) {
          return `${userPrefix}/empty-${timestamp}`;
        }
        const firstCommit = commits[0];
        const cleanMessage = firstCommit.message.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").slice(0, 50);
        const fullBranchName = `${userPrefix}/${cleanMessage}`;
        if (fullBranchName.length > 63) {
          const availableLength = 63 - userPrefix.length - 1;
          const truncatedMessage = cleanMessage.slice(0, availableLength);
          return `${userPrefix}/${truncatedMessage}`;
        }
        return fullBranchName;
    }
  }
  async pullLatestChanges(branch) {
    try {
      await Bun.$`git fetch origin`;
      const currentBranch = await this.getCurrentBranch();
      if (currentBranch !== branch) {
        await this.checkoutBranch(branch);
      }
      await Bun.$`git rebase origin/${branch}`;
    } catch (error) {
      try {
        await Bun.$`git rebase --abort`;
      } catch {}
      throw new Error(`Failed to pull latest changes for ${branch}: ${error}`);
    }
  }
  async fetchBranch(branch) {
    try {
      await Bun.$`git fetch origin ${branch}`;
    } catch (error) {
      throw new Error(`Failed to fetch branch ${branch}: ${error}`);
    }
  }
  async pushForceWithLease(branch) {
    try {
      await Bun.$`git push origin ${branch} --force-with-lease`;
    } catch (error) {
      throw new Error(`Failed to force push branch ${branch}: ${error}`);
    }
  }
  async rebaseOntoTarget(newBase, oldBase) {
    try {
      await Bun.$`git rebase --onto ${newBase} ${oldBase}`;
    } catch (error) {
      try {
        await Bun.$`git rebase --abort`;
      } catch {}
      throw new Error(`Failed to rebase onto ${newBase} from ${oldBase}. Please resolve conflicts manually.`);
    }
  }
}

// src/github-manager.ts
class GitHubManager {
  async isGitHubCLIAvailable() {
    try {
      await Bun.$`gh --version`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async isAuthenticated() {
    try {
      await Bun.$`gh auth status`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async getRepoInfo() {
    try {
      const result = await Bun.$`gh repo view --json owner,name`.text();
      const data = JSON.parse(result);
      return {
        owner: data.owner.login,
        repo: data.name
      };
    } catch (error) {
      throw new Error(`Failed to get repository info: ${error}`);
    }
  }
  async createPullRequest(title, body, head, base, draft = true) {
    try {
      const bodyFile = `/tmp/rungs-pr-body-${Date.now()}.txt`;
      await Bun.write(bodyFile, body);
      try {
        const args = ["gh", "pr", "create", "--title", title, "--body-file", bodyFile, "--head", head, "--base", base];
        if (draft) {
          args.push("--draft");
        }
        const prUrl = await Bun.$`${args}`.text();
        const prNumber = parseInt(prUrl.trim().split("/").pop() || "0");
        return {
          number: prNumber,
          title,
          body,
          url: prUrl.trim(),
          draft,
          head,
          base
        };
      } finally {
        try {
          await Bun.$`rm ${bodyFile}`.quiet();
        } catch {}
      }
    } catch (error) {
      let errorMessage = "Failed to create pull request";
      if (error.stderr) {
        errorMessage += `: ${error.stderr.toString().trim()}`;
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      } else {
        errorMessage += `: ${error}`;
      }
      if (error.stderr?.includes("remote ref does not exist") || head.length > 63) {
        errorMessage += `

Hint: Branch name may be too long. GitHub branch names must be 63 characters or less.`;
      }
      throw new Error(errorMessage);
    }
  }
  async updatePullRequest(prNumber, title, body) {
    try {
      const args = [];
      if (title) {
        args.push("--title", title);
      }
      if (body) {
        args.push("--body", body);
      }
      if (args.length > 0) {
        await Bun.$`gh pr edit ${prNumber} ${args}`;
      }
    } catch (error) {
      throw new Error(`Failed to update pull request #${prNumber}: ${error}`);
    }
  }
  async updatePullRequestBase(prNumber, newBase) {
    try {
      await Bun.$`gh pr edit ${prNumber} --base ${newBase}`;
    } catch (error) {
      throw new Error(`Failed to update pull request #${prNumber} base to ${newBase}: ${error}`);
    }
  }
  async mergePullRequest(prNumber, mergeMethod = "squash", deleteBranch = true) {
    try {
      const args = ["gh", "pr", "merge", prNumber.toString()];
      switch (mergeMethod) {
        case "squash":
          args.push("--squash");
          break;
        case "merge":
          args.push("--merge");
          break;
        case "rebase":
          args.push("--rebase");
          break;
      }
      if (deleteBranch) {
        args.push("--delete-branch");
      }
      await Bun.$`${args}`;
    } catch (error) {
      let errorMessage = `Failed to merge PR #${prNumber}`;
      if (error.stderr) {
        errorMessage += `: ${error.stderr.toString().trim()}`;
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      }
      throw new Error(errorMessage);
    }
  }
  async getPullRequest(branchName) {
    try {
      const result = await Bun.$`gh pr view ${branchName} --json number,title,body,url,isDraft,headRefName,baseRefName`.text();
      const data = JSON.parse(result);
      return {
        number: data.number,
        title: data.title,
        body: data.body,
        url: data.url,
        draft: data.isDraft,
        head: data.headRefName,
        base: data.baseRefName
      };
    } catch {
      return null;
    }
  }
  async getPullRequestByNumber(prNumber) {
    try {
      const result = await Bun.$`gh pr view ${prNumber} --json number,title,body,url,isDraft,headRefName,baseRefName`.text();
      const data = JSON.parse(result);
      return {
        number: data.number,
        title: data.title,
        body: data.body,
        url: data.url,
        draft: data.isDraft,
        head: data.headRefName,
        base: data.baseRefName
      };
    } catch {
      return null;
    }
  }
  async getPullRequestStatus(prNumber) {
    try {
      const result = await Bun.$`gh pr view ${prNumber} --json state`.text();
      const data = JSON.parse(result);
      return data.state.toLowerCase();
    } catch {
      return null;
    }
  }
  async listPullRequests(head) {
    try {
      let cmd = "gh pr list --json number,title,body,url,draft,headRefName,baseRefName";
      if (head) {
        cmd += ` --head ${head}`;
      }
      const result = await Bun.$`${cmd}`.text();
      const data = JSON.parse(result);
      return data.map((pr) => ({
        number: pr.number,
        title: pr.title,
        body: pr.body,
        url: pr.url,
        draft: pr.draft,
        head: pr.headRefName,
        base: pr.baseRefName
      }));
    } catch (error) {
      throw new Error(`Failed to list pull requests: ${error}`);
    }
  }
  async closePullRequest(prNumber) {
    try {
      await Bun.$`gh pr close ${prNumber}`;
    } catch (error) {
      throw new Error(`Failed to close pull request #${prNumber}: ${error}`);
    }
  }
  async publishPullRequest(prNumber) {
    try {
      await Bun.$`gh pr ready ${prNumber}`;
    } catch (error) {
      let errorMessage = `Failed to publish pull request #${prNumber}`;
      if (error.stderr) {
        const stderr = error.stderr.toString().trim();
        errorMessage += `: ${stderr}`;
        if (stderr.includes("not a draft")) {
          errorMessage += `

Hint: This PR is already published (not a draft).`;
        } else if (stderr.includes("not found")) {
          errorMessage += `

Hint: PR number may not exist or you may not have access to it.`;
        }
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      }
      throw new Error(errorMessage);
    }
  }
  generatePRTitle(commits) {
    if (commits.length === 0) {
      return "Empty stack";
    }
    if (commits.length === 1) {
      return commits[0].message;
    }
    return `${commits[0].message} (+${commits.length - 1} more)`;
  }
  generatePRBody(commits) {
    if (commits.length === 0) {
      return "Empty stack - no commits to include.";
    }
    if (commits.length === 1) {
      return `Single commit stack:

- ${commits[0].message}`;
    }
    const commitList = commits.map((commit) => `- ${commit.message}`).join(`
`);
    return `Stack of ${commits.length} commits:

${commitList}`;
  }
  async findPRsWithCommits(commitShas) {
    try {
      const result = await Bun.$`gh pr list --state open --json number,title,url,headRefName`.text();
      const openPRs = JSON.parse(result);
      const matchingPRs = [];
      for (const pr of openPRs) {
        try {
          const branchCommitsResult = await Bun.$`git log origin/${pr.headRefName} --pretty=format:"%H"`.text();
          const branchCommits = branchCommitsResult.trim().split(`
`).filter(Boolean);
          const hasMatchingCommits = commitShas.some((sha) => branchCommits.some((branchSha) => branchSha.startsWith(sha) || sha.startsWith(branchSha)));
          if (hasMatchingCommits) {
            matchingPRs.push({
              number: pr.number,
              url: pr.url,
              title: pr.title,
              status: "open"
            });
          }
        } catch (error) {
          continue;
        }
      }
      return matchingPRs;
    } catch (error) {
      throw new Error(`Failed to search for PRs with commits: ${error}`);
    }
  }
}

// src/config-manager.ts
import { join } from "path";
import { homedir } from "os";
var DEFAULT_CONFIG = {
  userPrefix: "dev",
  defaultBranch: "main",
  draftPRs: true,
  autoRebase: true,
  branchNaming: "commit-message",
  output: {
    mode: "compact",
    verboseOnError: true,
    spinnerStyle: "dots",
    colorScheme: "auto",
    maxLineLength: 80,
    showTimestamps: false,
    showElapsedTime: false
  }
};

class ConfigManager {
  configPath;
  constructor(customPath) {
    this.configPath = customPath || join(homedir(), ".config", "rungs", "config.json");
  }
  async ensureConfigDir() {
    const configDir = this.configPath.split("/").slice(0, -1).join("/");
    try {
      await Bun.$`mkdir -p ${configDir}`;
    } catch (error) {
      throw new Error(`Failed to create config directory: ${error}`);
    }
  }
  async getAll() {
    try {
      const file = Bun.file(this.configPath);
      if (!await file.exists()) {
        return DEFAULT_CONFIG;
      }
      const content = await file.text();
      const config = JSON.parse(content);
      return { ...DEFAULT_CONFIG, ...config };
    } catch (error) {
      console.warn(`Failed to read config file, using defaults: ${error}`);
      return DEFAULT_CONFIG;
    }
  }
  async get(key) {
    const config = await this.getAll();
    return config[key];
  }
  async set(key, value) {
    await this.ensureConfigDir();
    const config = await this.getAll();
    config[key] = value;
    try {
      await Bun.write(this.configPath, JSON.stringify(config, null, 2));
    } catch (error) {
      throw new Error(`Failed to write config file: ${error}`);
    }
  }
  async update(updates) {
    await this.ensureConfigDir();
    const config = await this.getAll();
    const newConfig = { ...config, ...updates };
    try {
      await Bun.write(this.configPath, JSON.stringify(newConfig, null, 2));
    } catch (error) {
      throw new Error(`Failed to update config file: ${error}`);
    }
  }
  async reset() {
    await this.ensureConfigDir();
    try {
      await Bun.write(this.configPath, JSON.stringify(DEFAULT_CONFIG, null, 2));
    } catch (error) {
      throw new Error(`Failed to reset config file: ${error}`);
    }
  }
}

// src/ansi-utils.ts
class AnsiUtils {
  static ESCAPE_CODES = {
    cursorUp: (lines) => `\x1B[${lines}A`,
    cursorDown: (lines) => `\x1B[${lines}B`,
    cursorForward: (cols) => `\x1B[${cols}C`,
    cursorBack: (cols) => `\x1B[${cols}D`,
    cursorToColumn: (col) => `\x1B[${col}G`,
    cursorHome: "\x1B[H",
    clearLine: "\x1B[2K",
    clearLineAfter: "\x1B[0K",
    clearLineBefore: "\x1B[1K",
    clearScreen: "\x1B[2J",
    clearScreenAfter: "\x1B[0J",
    clearScreenBefore: "\x1B[1J",
    saveCursor: "\x1B[s",
    restoreCursor: "\x1B[u",
    bold: "\x1B[1m",
    dim: "\x1B[2m",
    italic: "\x1B[3m",
    underline: "\x1B[4m",
    blink: "\x1B[5m",
    reverse: "\x1B[7m",
    strikethrough: "\x1B[9m",
    reset: "\x1B[0m",
    colors: {
      black: "\x1B[30m",
      red: "\x1B[31m",
      green: "\x1B[32m",
      yellow: "\x1B[33m",
      blue: "\x1B[34m",
      magenta: "\x1B[35m",
      cyan: "\x1B[36m",
      white: "\x1B[37m",
      gray: "\x1B[90m",
      brightRed: "\x1B[91m",
      brightGreen: "\x1B[92m",
      brightYellow: "\x1B[93m",
      brightBlue: "\x1B[94m",
      brightMagenta: "\x1B[95m",
      brightCyan: "\x1B[96m",
      brightWhite: "\x1B[97m"
    },
    bgColors: {
      black: "\x1B[40m",
      red: "\x1B[41m",
      green: "\x1B[42m",
      yellow: "\x1B[43m",
      blue: "\x1B[44m",
      magenta: "\x1B[45m",
      cyan: "\x1B[46m",
      white: "\x1B[47m",
      gray: "\x1B[100m",
      brightRed: "\x1B[101m",
      brightGreen: "\x1B[102m",
      brightYellow: "\x1B[103m",
      brightBlue: "\x1B[104m",
      brightMagenta: "\x1B[105m",
      brightCyan: "\x1B[106m",
      brightWhite: "\x1B[107m"
    }
  };
  static capabilities = null;
  static getTerminalCapabilities() {
    if (this.capabilities) {
      return this.capabilities;
    }
    const isInteractive = Boolean(process.stdout.isTTY);
    const supportsColors = isInteractive && !process.env.NO_COLOR && (process.env.COLORTERM === "truecolor" || process.env.TERM === "xterm-256color" || process.env.TERM === "screen-256color" || Boolean(process.env.FORCE_COLOR));
    this.capabilities = {
      supportsCursor: isInteractive,
      supportsColors,
      supportsUnicode: true,
      isInteractive
    };
    return this.capabilities;
  }
  static isTerminalSupported() {
    return this.getTerminalCapabilities().isInteractive;
  }
  static supportsColors() {
    return this.getTerminalCapabilities().supportsColors;
  }
  static clearCurrentLine() {
    if (this.isTerminalSupported()) {
      process.stdout.write(this.ESCAPE_CODES.clearLine);
    }
  }
  static moveCursorToStart() {
    if (this.isTerminalSupported()) {
      process.stdout.write(this.ESCAPE_CODES.cursorToColumn(1));
    }
  }
  static replaceCurrentLine(text) {
    if (this.isTerminalSupported()) {
      this.clearCurrentLine();
      this.moveCursorToStart();
      process.stdout.write(text);
    } else {
      console.log(text);
    }
  }
  static moveCursorUp(lines) {
    if (this.isTerminalSupported() && lines > 0) {
      process.stdout.write(this.ESCAPE_CODES.cursorUp(lines));
    }
  }
  static moveCursorDown(lines) {
    if (this.isTerminalSupported() && lines > 0) {
      process.stdout.write(this.ESCAPE_CODES.cursorDown(lines));
    }
  }
  static saveCursor() {
    if (this.isTerminalSupported()) {
      process.stdout.write(this.ESCAPE_CODES.saveCursor);
    }
  }
  static restoreCursor() {
    if (this.isTerminalSupported()) {
      process.stdout.write(this.ESCAPE_CODES.restoreCursor);
    }
  }
  static formatText(text, styles) {
    if (!this.supportsColors() || styles.length === 0) {
      return text;
    }
    const codes = [];
    for (const style of styles) {
      if (style in this.ESCAPE_CODES && typeof this.ESCAPE_CODES[style] === "string") {
        codes.push(this.ESCAPE_CODES[style]);
      } else if (style in this.ESCAPE_CODES.colors) {
        codes.push(this.ESCAPE_CODES.colors[style]);
      } else if (style in this.ESCAPE_CODES.bgColors) {
        codes.push(this.ESCAPE_CODES.bgColors[style]);
      }
    }
    if (codes.length === 0) {
      return text;
    }
    return `${codes.join("")}${text}${this.ESCAPE_CODES.reset}`;
  }
  static colorize(text, color) {
    return this.formatText(text, [color]);
  }
  static bold(text) {
    return this.formatText(text, ["bold"]);
  }
  static italic(text) {
    return this.formatText(text, ["italic"]);
  }
  static dim(text) {
    return this.formatText(text, ["dim"]);
  }
  static underline(text) {
    return this.formatText(text, ["underline"]);
  }
  static truncate(text, maxWidth, ellipsis = "...") {
    if (text.length <= maxWidth) {
      return text;
    }
    if (maxWidth <= ellipsis.length) {
      return ellipsis.slice(0, maxWidth);
    }
    return text.slice(0, maxWidth - ellipsis.length) + ellipsis;
  }
  static pad(text, width, char = " ", align = "left") {
    if (text.length >= width) {
      return text;
    }
    const padding = width - text.length;
    switch (align) {
      case "right":
        return char.repeat(padding) + text;
      case "center":
        const leftPad = Math.floor(padding / 2);
        const rightPad = padding - leftPad;
        return char.repeat(leftPad) + text + char.repeat(rightPad);
      case "left":
      default:
        return text + char.repeat(padding);
    }
  }
  static getTerminalWidth() {
    return process.stdout.columns || 80;
  }
  static getTerminalHeight() {
    return process.stdout.rows || 24;
  }
  static refreshCapabilities() {
    this.capabilities = null;
  }
}

// src/progress-indicator.ts
class ProgressIndicator {
  text;
  options;
  static SPINNERS = {
    dots: ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"],
    line: ["|", "/", "-", "\\"],
    arrow: ["\u2190", "\u2196", "\u2191", "\u2197", "\u2192", "\u2198", "\u2193", "\u2199"],
    clock: ["\uD83D\uDD50", "\uD83D\uDD51", "\uD83D\uDD52", "\uD83D\uDD53", "\uD83D\uDD54", "\uD83D\uDD55", "\uD83D\uDD56", "\uD83D\uDD57", "\uD83D\uDD58", "\uD83D\uDD59", "\uD83D\uDD5A", "\uD83D\uDD5B"],
    none: [""]
  };
  intervalId;
  currentFrame = 0;
  isActive = false;
  lastText = "";
  constructor(text, options = {}) {
    this.text = text;
    this.options = options;
    this.options = {
      style: "dots",
      color: "cyan",
      interval: 80,
      prefix: "",
      suffix: "",
      ...options
    };
  }
  start() {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    this.currentFrame = 0;
    if (!AnsiUtils.isTerminalSupported()) {
      const staticText = this.formatStaticText();
      console.log(staticText);
      return;
    }
    this.intervalId = setInterval(() => {
      this.updateDisplay();
    }, this.options.interval);
    this.updateDisplay();
  }
  stop() {
    if (!this.isActive) {
      return;
    }
    this.isActive = false;
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
  }
  updateText(text) {
    this.text = text;
    if (this.isActive && AnsiUtils.isTerminalSupported()) {
      this.updateDisplay();
    }
  }
  success(message, icon = "\u2705") {
    this.stop();
    const finalText = this.formatFinalText(message, icon, "green");
    this.replaceOrPrint(finalText);
  }
  error(message, icon = "\u274C") {
    this.stop();
    const finalText = this.formatFinalText(message, icon, "red");
    this.replaceOrPrint(finalText);
  }
  warn(message, icon = "\u26A0\uFE0F") {
    this.stop();
    const finalText = this.formatFinalText(message, icon, "yellow");
    this.replaceOrPrint(finalText);
  }
  info(message, icon = "\u2139\uFE0F") {
    this.stop();
    const finalText = this.formatFinalText(message, icon, "blue");
    this.replaceOrPrint(finalText);
  }
  isRunning() {
    return this.isActive;
  }
  updateDisplay() {
    const spinner = this.getCurrentSpinner();
    const frames = ProgressIndicator.SPINNERS[this.options.style || "dots"];
    const frame = frames[this.currentFrame % frames.length];
    const displayText = this.formatDisplayText(frame);
    if (AnsiUtils.isTerminalSupported()) {
      AnsiUtils.replaceCurrentLine(displayText);
    }
    this.lastText = displayText;
    this.currentFrame++;
  }
  getCurrentSpinner() {
    return ProgressIndicator.SPINNERS[this.options.style || "dots"];
  }
  formatDisplayText(frame) {
    const { prefix = "", suffix = "", color = "cyan" } = this.options;
    let displayText = "";
    if (prefix) {
      displayText += prefix + " ";
    }
    if (frame && this.options.style !== "none") {
      const coloredFrame = AnsiUtils.colorize(frame, color);
      displayText += coloredFrame + " ";
    }
    displayText += this.text;
    if (suffix) {
      displayText += " " + suffix;
    }
    return displayText;
  }
  formatStaticText() {
    const { prefix = "", suffix = "" } = this.options;
    let displayText = "";
    if (prefix) {
      displayText += prefix + " ";
    }
    displayText += this.text;
    if (suffix) {
      displayText += " " + suffix;
    }
    return displayText;
  }
  formatFinalText(message, icon, color) {
    const { prefix = "", suffix = "" } = this.options;
    let displayText = "";
    if (prefix) {
      displayText += prefix + " ";
    }
    const coloredIcon = AnsiUtils.colorize(icon, color);
    displayText += coloredIcon + " ";
    displayText += AnsiUtils.formatText(message, ["bold"]);
    if (suffix) {
      displayText += " " + suffix;
    }
    return displayText;
  }
  replaceOrPrint(text) {
    if (AnsiUtils.isTerminalSupported() && this.lastText) {
      AnsiUtils.replaceCurrentLine(text);
      console.log();
    } else {
      console.log(text);
    }
  }
}

// src/output-manager.ts
class OutputManager {
  indentLevel = 0;
  currentSection = null;
  config;
  activeOperations = new Map;
  operationStack = [];
  lastOutputWasCompact = false;
  static ICONS = {
    git: "\uD83D\uDD04",
    github: "\uD83D\uDCE4",
    stack: "\uD83D\uDCDA",
    config: "\u2699\uFE0F",
    general: "\uD83D\uDCBB",
    success: "\u2705",
    error: "\u274C",
    warning: "\u26A0\uFE0F",
    info: "\u2139\uFE0F",
    progress: "\uD83D\uDD04"
  };
  static COLORS = {
    reset: "\x1B[0m",
    bright: "\x1B[1m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    gray: "\x1B[90m"
  };
  constructor(config = {}) {
    this.config = {
      showTimestamps: false,
      useColors: true,
      verboseMode: false,
      outputMode: "compact",
      spinnerStyle: "dots",
      maxLineLength: 80,
      showElapsedTime: false,
      ...config
    };
  }
  startSection(title, type = "general") {
    if (this.currentSection) {
      this.endSection();
    }
    const icon = OutputManager.ICONS[type];
    const separator = "\u2550".repeat(Math.max(20, title.length + 10));
    console.log();
    console.log(this.colorize(`${separator}`, "cyan"));
    console.log(this.colorize(`${icon} ${title.toUpperCase()}`, "bright"));
    console.log(this.colorize(`${separator}`, "cyan"));
    console.log();
    this.currentSection = title;
    this.indentLevel = 0;
  }
  endSection() {
    if (!this.currentSection)
      return;
    console.log();
    console.log(this.colorize("\u2550".repeat(30), "cyan"));
    console.log();
    this.currentSection = null;
    this.indentLevel = 0;
  }
  log(message, level = "info", indent = 0, options) {
    if (this.config.outputMode === "compact" && this.lastOutputWasCompact) {
      console.log();
      this.lastOutputWasCompact = false;
    }
    const icon = OutputManager.ICONS[level];
    const prefix = this.getPrefix(icon, level);
    const indentation = "  ".repeat(this.indentLevel + indent);
    let formattedMessage = `${indentation}${prefix} ${message}`;
    if (this.config.outputMode === "compact" && options?.truncate && this.config.maxLineLength > 0) {
      const maxLength = this.config.maxLineLength - indentation.length - prefix.length - 1;
      if (message.length > maxLength) {
        formattedMessage = `${indentation}${prefix} ${AnsiUtils.truncate(message, maxLength)}`;
      }
    }
    console.log(this.colorize(formattedMessage, this.getLevelColor(level)));
  }
  progress(message, indent = 0) {
    this.log(message, "progress", indent);
  }
  success(message, indent = 0) {
    this.log(message, "success", indent);
  }
  error(message, indent = 0) {
    this.log(message, "error", indent);
  }
  warning(message, indent = 0) {
    this.log(message, "warning", indent);
  }
  info(message, indent = 0) {
    this.log(message, "info", indent);
  }
  startGroup(title, type = "general") {
    const icon = OutputManager.ICONS[type];
    const indentation = "  ".repeat(this.indentLevel);
    console.log();
    console.log(this.colorize(`${indentation}${icon} ${title}:`, "bright"));
    this.indentLevel++;
  }
  endGroup() {
    if (this.indentLevel > 0) {
      this.indentLevel--;
    }
    console.log();
  }
  logList(items, title, level = "info") {
    if (title) {
      this.log(title, level);
    }
    items.forEach((item) => {
      const indentation = "  ".repeat(this.indentLevel + 1);
      console.log(this.colorize(`${indentation}- ${item}`, this.getLevelColor(level)));
    });
  }
  logCommand(command) {
    if (this.config.verboseMode) {
      const indentation = "  ".repeat(this.indentLevel);
      console.log(this.colorize(`${indentation}$ ${command}`, "gray"));
    }
  }
  summary(title, items) {
    console.log();
    console.log(this.colorize(`\uD83D\uDCCB ${title}:`, "bright"));
    const maxLabelLength = Math.max(...items.map((item) => item.label.length));
    items.forEach((item) => {
      const paddedLabel = item.label.padEnd(maxLabelLength);
      const indentation = "  ".repeat(this.indentLevel + 1);
      console.log(this.colorize(`${indentation}${paddedLabel}: ${item.value}`, "info"));
    });
    console.log();
  }
  separator(char = "\u2500", length = 40) {
    const indentation = "  ".repeat(this.indentLevel);
    console.log(this.colorize(`${indentation}${char.repeat(length)}`, "gray"));
  }
  setVerbose(verbose) {
    this.config.verboseMode = verbose;
  }
  setOutputMode(mode) {
    this.config.outputMode = mode;
  }
  getOutputMode() {
    return this.config.outputMode;
  }
  startOperation(id, message, type = "general") {
    if (this.config.outputMode === "verbose") {
      this.startGroup(message, type);
      return;
    }
    this.completeOperation(id, "", "success");
    const icon = OutputManager.ICONS[type];
    const displayMessage = `${icon} ${message}`;
    const progressIndicator = new ProgressIndicator(displayMessage, {
      style: this.config.spinnerStyle,
      color: this.getTypeColor(type)
    });
    this.activeOperations.set(id, progressIndicator);
    this.operationStack.push(id);
    progressIndicator.start();
    this.lastOutputWasCompact = true;
  }
  updateOperation(id, message) {
    if (this.config.outputMode === "verbose") {
      this.progress(message);
      return;
    }
    const operation = this.activeOperations.get(id);
    if (operation && operation.isRunning()) {
      operation.updateText(message);
    }
  }
  completeOperation(id, message, level = "success") {
    if (this.config.outputMode === "verbose") {
      if (message) {
        this.log(message, level);
      }
      this.endGroup();
      return;
    }
    const operation = this.activeOperations.get(id);
    if (operation && operation.isRunning()) {
      const finalMessage = message || "Completed";
      switch (level) {
        case "success":
          operation.success(finalMessage);
          break;
        case "error":
          operation.error(finalMessage);
          break;
        case "warning":
          operation.warn(finalMessage);
          break;
        case "info":
          operation.info(finalMessage);
          break;
        default:
          operation.success(finalMessage);
      }
      this.activeOperations.delete(id);
      this.operationStack = this.operationStack.filter((opId) => opId !== id);
    }
  }
  failOperation(id, message, error) {
    if (this.config.outputMode === "verbose") {
      this.error(message);
      if (error) {
        this.error(error, 1);
      }
      this.endGroup();
      return;
    }
    const operation = this.activeOperations.get(id);
    if (operation && operation.isRunning()) {
      const errorMessage = error ? `${message}: ${error}` : message;
      operation.error(errorMessage);
      this.activeOperations.delete(id);
      this.operationStack = this.operationStack.filter((opId) => opId !== id);
    }
  }
  getPrefix(icon, level) {
    if (this.config.showTimestamps) {
      const timestamp = new Date().toLocaleTimeString();
      return `[${timestamp}] ${icon}`;
    }
    return icon;
  }
  getLevelColor(level) {
    switch (level) {
      case "success":
        return "green";
      case "error":
        return "red";
      case "warning":
        return "yellow";
      case "progress":
        return "cyan";
      case "info":
      default:
        return "reset";
    }
  }
  getTypeColor(type) {
    switch (type) {
      case "git":
        return "blue";
      case "github":
        return "magenta";
      case "stack":
        return "cyan";
      case "config":
        return "yellow";
      case "general":
      default:
        return "white";
    }
  }
  colorize(text, color) {
    if (!this.config.useColors) {
      return text;
    }
    const colorCode = OutputManager.COLORS[color];
    if (!colorCode) {
      return text;
    }
    return `${colorCode}${text}${OutputManager.COLORS.reset}`;
  }
}
var output = new OutputManager;
function logProgress(message, indent = 0) {
  output.progress(message, indent);
}
function logSuccess(message, indent = 0) {
  output.success(message, indent);
}
function logWarning(message, indent = 0) {
  output.warning(message, indent);
}
function logInfo(message, indent = 0) {
  output.info(message, indent);
}
function startGroup(title, type = "general") {
  output.startGroup(title, type);
}
function endGroup() {
  output.endGroup();
}
function logSummary(title, items) {
  output.summary(title, items);
}
function setVerbose(verbose) {
  output.setVerbose(verbose);
}
function setOutputMode(mode) {
  output.setOutputMode(mode);
}

// src/operation-tracker.ts
class OperationTracker {
  output;
  operationCounter = 0;
  constructor(output2) {
    this.output = output2;
  }
  async executeOperation(id, description, type, operation, options = {}) {
    const startTime = Date.now();
    try {
      this.output.startOperation(id, description, type);
      const result = await operation();
      let successMessage = options.successMessage ? options.successMessage(result) : description;
      if (options.showElapsed) {
        const elapsed = Date.now() - startTime;
        successMessage += ` (${elapsed}ms)`;
      }
      this.output.completeOperation(id, successMessage, "success");
      return result;
    } catch (error) {
      const errorMessage = options.errorMessage && error instanceof Error ? options.errorMessage(error) : `${description} failed`;
      const errorDetail = error instanceof Error ? error.message : String(error);
      this.output.failOperation(id, errorMessage, errorDetail);
      throw error;
    }
  }
  executeOperationSync(id, description, type, operation, options = {}) {
    const startTime = Date.now();
    try {
      this.output.startOperation(id, description, type);
      const result = operation();
      let successMessage = options.successMessage ? options.successMessage(result) : description;
      if (options.showElapsed) {
        const elapsed = Date.now() - startTime;
        successMessage += ` (${elapsed}ms)`;
      }
      this.output.completeOperation(id, successMessage, "success");
      return result;
    } catch (error) {
      const errorMessage = options.errorMessage && error instanceof Error ? options.errorMessage(error) : `${description} failed`;
      const errorDetail = error instanceof Error ? error.message : String(error);
      this.output.failOperation(id, errorMessage, errorDetail);
      throw error;
    }
  }
  createOperationId(prefix) {
    return `${prefix}-${++this.operationCounter}-${Date.now()}`;
  }
  async gitOperation(description, operation, options = {}) {
    const id = this.createOperationId("git");
    return this.executeOperation(id, description, "git", operation, options);
  }
  async githubOperation(description, operation, options = {}) {
    const id = this.createOperationId("github");
    return this.executeOperation(id, description, "github", operation, options);
  }
  async stackOperation(description, operation, options = {}) {
    const id = this.createOperationId("stack");
    return this.executeOperation(id, description, "stack", operation, options);
  }
  async configOperation(description, operation, options = {}) {
    const id = this.createOperationId("config");
    return this.executeOperation(id, description, "config", operation, options);
  }
  async generalOperation(description, operation, options = {}) {
    const id = this.createOperationId("general");
    return this.executeOperation(id, description, "general", operation, options);
  }
  gitOperationSync(description, operation, options = {}) {
    const id = this.createOperationId("git");
    return this.executeOperationSync(id, description, "git", operation, options);
  }
  githubOperationSync(description, operation, options = {}) {
    const id = this.createOperationId("github");
    return this.executeOperationSync(id, description, "github", operation, options);
  }
  stackOperationSync(description, operation, options = {}) {
    const id = this.createOperationId("stack");
    return this.executeOperationSync(id, description, "stack", operation, options);
  }
  updateOperation(id, newDescription) {
    this.output.updateOperation(id, newDescription);
  }
  startOperation(description, type = "general") {
    const id = this.createOperationId(type);
    this.output.startOperation(id, description, type);
    return id;
  }
  completeOperation(id, message, level = "success") {
    this.output.completeOperation(id, message || "Completed", level);
  }
  failOperation(id, message, error) {
    this.output.failOperation(id, message, error);
  }
  async executeSequence(operations) {
    const results = [];
    for (const op of operations) {
      const result = await this.executeOperation(this.createOperationId(op.type), op.description, op.type, op.operation, op.options || {});
      results.push(result);
    }
    return results;
  }
  async executeParallel(operations) {
    const promises = operations.map((op) => this.executeOperation(this.createOperationId(op.type), op.description, op.type, op.operation, op.options || {}));
    return Promise.all(promises);
  }
  getOutputManager() {
    return this.output;
  }
}

// src/stack-manager.ts
class StackManager {
  config;
  git;
  github;
  outputMode;
  tracker;
  constructor(config, git, github, outputMode = "verbose") {
    this.config = config;
    this.git = git;
    this.github = github;
    this.outputMode = outputMode;
    this.tracker = new OperationTracker(output);
  }
  async ensurePrerequisites() {
    if (!await this.git.isGitRepo()) {
      throw new Error("Not in a git repository. Run 'git init' to initialize a repository.");
    }
    if (!await this.github.isGitHubCLIAvailable()) {
      throw new Error("GitHub CLI (gh) is not installed or not in PATH. Install from https://cli.github.com/");
    }
    if (!await this.github.isAuthenticated()) {
      throw new Error("Not authenticated with GitHub CLI. Run 'gh auth login' to authenticate.");
    }
  }
  async getCurrentStack() {
    if (this.outputMode === "compact") {
      return await this.tracker.githubOperation("Discovering stack from GitHub", async () => {
        const config = await this.config.getAll();
        const result = await Bun.$`gh pr list --author @me --state open --json number,title,url,headRefName,baseRefName`.text();
        const allPRs = JSON.parse(result);
        const stackPRs = allPRs.filter((pr) => pr.headRefName.startsWith(config.userPrefix + "/"));
        if (stackPRs.length === 0) {
          return { prs: [], totalCommits: 0 };
        }
        const orderedPRs = this.buildStackOrder(stackPRs, config.defaultBranch);
        const fixedPRs = await this.autoFixBrokenChains(orderedPRs, config.defaultBranch);
        const stackState = {
          prs: fixedPRs.map((pr) => ({
            number: pr.number,
            branch: pr.headRefName,
            title: pr.title,
            url: pr.url,
            base: pr.baseRefName,
            head: pr.headRefName
          })),
          totalCommits: 0,
          lastBranch: fixedPRs.length > 0 ? fixedPRs[fixedPRs.length - 1].headRefName : undefined
        };
        return stackState;
      });
    } else {
      startGroup("Discovering Stack from GitHub", "github");
      try {
        const config = await this.config.getAll();
        logProgress("Fetching open PRs...");
        const result = await Bun.$`gh pr list --author @me --state open --json number,title,url,headRefName,baseRefName`.text();
        const allPRs = JSON.parse(result);
        const stackPRs = allPRs.filter((pr) => pr.headRefName.startsWith(config.userPrefix + "/"));
        logInfo(`Found ${stackPRs.length} stack PRs out of ${allPRs.length} total open PRs`, 1);
        if (stackPRs.length === 0) {
          endGroup();
          return { prs: [], totalCommits: 0 };
        }
        logProgress("Building stack order from base chains...");
        const orderedPRs = this.buildStackOrder(stackPRs, config.defaultBranch);
        logProgress("Validating and auto-fixing broken chains...");
        const fixedPRs = await this.autoFixBrokenChains(orderedPRs, config.defaultBranch);
        const stackState = {
          prs: fixedPRs.map((pr) => ({
            number: pr.number,
            branch: pr.headRefName,
            title: pr.title,
            url: pr.url,
            base: pr.baseRefName,
            head: pr.headRefName
          })),
          totalCommits: 0,
          lastBranch: fixedPRs.length > 0 ? fixedPRs[fixedPRs.length - 1].headRefName : undefined
        };
        logSuccess(`Stack discovered: ${fixedPRs.length} PRs in order`);
        if (fixedPRs.length > 0) {
          const stackOrder = fixedPRs.map((pr, i) => `${i + 1}. PR #${pr.number}: ${pr.headRefName} <- ${pr.baseRefName}`);
          output.logList(stackOrder, "Stack Order:", "info");
        }
        endGroup();
        return stackState;
      } catch (error) {
        endGroup();
        throw new Error(`Failed to discover stack from GitHub: ${error}`);
      }
    }
  }
  async getNewCommits() {
    startGroup("Finding New Commits", "git");
    try {
      const config = await this.config.getAll();
      const currentStack = await this.getCurrentStack();
      logProgress("Determining base reference...");
      const exclusions = [`origin/${config.defaultBranch}`];
      for (const pr of currentStack.prs) {
        exclusions.push(`origin/${pr.branch}`);
      }
      logInfo(`Excluding commits from: ${exclusions.join(", ")}`, 1);
      logProgress("Scanning for new commits...");
      let newCommits = [];
      for (const exclusion of exclusions) {
        try {
          await Bun.$`git rev-parse --verify ${exclusion}`.quiet();
          const commitsFromThisRef = await this.git.getCommitsSince(exclusion);
          if (commitsFromThisRef.length > 0) {
            if (newCommits.length === 0 || commitsFromThisRef.length < newCommits.length) {
              newCommits = commitsFromThisRef;
              logInfo(`Using ${exclusion} as base (${commitsFromThisRef.length} new commits)`, 1);
            }
          }
        } catch {
          continue;
        }
      }
      if (newCommits.length === 0) {
        try {
          newCommits = await this.git.getCommitsSince(`origin/${config.defaultBranch}`);
          logInfo(`Falling back to origin/${config.defaultBranch}`, 1);
        } catch {
          try {
            const rootCommit = await Bun.$`git rev-list --max-parents=0 HEAD`.text();
            const baseRef = rootCommit.trim().split(`
`)[0];
            newCommits = await this.git.getCommitsSince(baseRef);
            logInfo(`Using root commit as base`, 1);
          } catch {
            newCommits = [];
          }
        }
      }
      logSuccess(`Found ${newCommits.length} new commits`);
      if (newCommits.length > 0) {
        const commitList = newCommits.map((c) => `${c.hash.slice(0, 7)}: ${c.message}`);
        output.logList(commitList, "New commits:", "info");
      }
      endGroup();
      return newCommits;
    } catch (error) {
      endGroup();
      throw new Error(`Failed to find new commits: ${error}`);
    }
  }
  buildStackOrder(prs, defaultBranch) {
    const orderedPRs = [];
    const remaining = [...prs];
    let currentBase = defaultBranch;
    while (remaining.length > 0) {
      const nextPR = remaining.find((pr) => pr.baseRefName === currentBase);
      if (!nextPR) {
        if (remaining.length > 0) {
          logWarning(`Broken chain detected: ${remaining.length} PRs don't follow proper base chain`, 1);
          orderedPRs.push(...remaining);
        }
        break;
      }
      orderedPRs.push(nextPR);
      remaining.splice(remaining.indexOf(nextPR), 1);
      currentBase = nextPR.headRefName;
    }
    return orderedPRs;
  }
  async autoFixBrokenChains(prs, defaultBranch) {
    const fixedPRs = [...prs];
    const needsFixing = [];
    for (let i = 0;i < fixedPRs.length; i++) {
      const pr = fixedPRs[i];
      const expectedBase = i === 0 ? defaultBranch : fixedPRs[i - 1].headRefName;
      if (pr.baseRefName !== expectedBase) {
        needsFixing.push({
          prNumber: pr.number,
          currentBase: pr.baseRefName,
          correctBase: expectedBase
        });
        fixedPRs[i] = { ...pr, baseRefName: expectedBase };
      }
    }
    if (needsFixing.length > 0) {
      startGroup(`Auto-fixing ${needsFixing.length} broken base chains`, "github");
      for (const fix of needsFixing) {
        try {
          logProgress(`Updating PR #${fix.prNumber}: ${fix.currentBase} -> ${fix.correctBase}`, 1);
          await this.github.updatePullRequestBase(fix.prNumber, fix.correctBase);
          logSuccess(`Fixed PR #${fix.prNumber} base`, 1);
        } catch (error) {
          logWarning(`Could not fix PR #${fix.prNumber} base: ${error}`, 1);
        }
      }
      endGroup();
    }
    return fixedPRs;
  }
  async pushStack(autoPublish = false, force = false) {
    await this.ensurePrerequisites();
    const config = await this.config.getAll();
    const currentBranch = await this.git.getCurrentBranch();
    if (currentBranch !== config.defaultBranch) {
      throw new Error(`Must be on ${config.defaultBranch} branch to push stack. Currently on ${currentBranch}.`);
    }
    const status = await this.git.getStatus();
    if (!status.isClean) {
      throw new Error("Working directory is not clean. Please commit or stash changes.");
    }
    if (!force) {
      await this.validateSyncStatus(config.defaultBranch);
    }
    if (config.autoRebase) {
      startGroup("Fetching Latest Changes", "git");
      logProgress("Fetching from origin...");
      await this.git.fetchOrigin();
      logSuccess("Fetched latest changes");
      if (status.behind > 0) {
        logProgress(`Rebasing ${status.behind} commits...`);
        await this.git.rebaseOnto(config.defaultBranch);
        logSuccess("Rebase completed");
      }
      endGroup();
    }
    const newCommits = await this.getNewCommits();
    if (newCommits.length === 0) {
      logInfo("No new commits to process.");
      return;
    }
    startGroup("Processing Commits", "git");
    logInfo(`Found ${newCommits.length} new commits to process.`);
    const commitList = newCommits.map((c) => `${c.hash.slice(0, 7)}: ${c.message}`);
    output.logList(commitList, "Commits to process:", "info");
    endGroup();
    startGroup("Checking for Duplicate PRs", "github");
    logProgress("Searching for existing PRs with these commits...");
    const commitShas = newCommits.map((c) => c.hash);
    const existingPRs = await this.github.findPRsWithCommits(commitShas);
    if (existingPRs.length > 0) {
      const existingPR = existingPRs[0];
      endGroup();
      logWarning("\u274C These commits already exist in an existing PR");
      logInfo(`PR #${existingPR.number}: ${existingPR.title}`);
      logInfo(`URL: ${existingPR.url}`);
      logInfo(`Status: ${existingPR.status}`);
      logInfo("");
      logInfo("No new PR created. You can:");
      logInfo(`  - Update PR #${existingPR.number} if needed`);
      logInfo("  - Run 'rungs status' to see current PRs");
      return;
    }
    logSuccess("No duplicate PRs found");
    endGroup();
    const branchName = this.git.generateBranchName(newCommits, config.userPrefix, config.branchNaming);
    if (await this.git.branchExists(branchName)) {
      throw new Error(`Branch ${branchName} already exists. Please delete it or use a different naming strategy.`);
    }
    startGroup("Creating Branch", "git");
    logProgress(`Creating branch: ${branchName}`);
    await this.git.createBranch(branchName);
    logProgress("Pushing branch to remote...");
    await this.git.pushBranch(branchName);
    logSuccess("Branch created and pushed");
    endGroup();
    startGroup("Creating Pull Request", "github");
    const prTitle = this.github.generatePRTitle(newCommits);
    const prBody = this.github.generatePRBody(newCommits);
    const currentStack = await this.getCurrentStack();
    const baseBranch = currentStack.lastBranch || config.defaultBranch;
    logProgress(`Creating PR: "${prTitle}"`);
    logInfo(`Base branch: ${baseBranch}`, 1);
    const isDraft = autoPublish ? false : config.draftPRs;
    logInfo(`Draft mode: ${isDraft ? "Yes" : "No (published)"}`, 1);
    const pr = await this.github.createPullRequest(prTitle, prBody, branchName, baseBranch, isDraft);
    logSuccess(`Created pull request: ${pr.url}`);
    endGroup();
    startGroup("Finalizing", "stack");
    logProgress("Switching back to main branch...");
    await this.git.checkoutBranch(config.defaultBranch);
    logSuccess("Returned to main branch");
    endGroup();
    logSummary("Stack Created Successfully", [
      { label: "Branch", value: branchName },
      { label: "Pull Request", value: `#${pr.number}` },
      { label: "URL", value: pr.url }
    ]);
    logInfo(`You can now continue working on ${config.defaultBranch} and run 'rungs stack' again for additional commits.`);
  }
  async getStatus() {
    await this.ensurePrerequisites();
    const config = await this.config.getAll();
    const gitStatus = await this.git.getStatus();
    const currentStack = await this.getCurrentStack();
    const newCommits = await this.getNewCommits();
    let statusMessage = `
Current Status:
- Branch: ${gitStatus.currentBranch}
- Clean: ${gitStatus.isClean ? "Yes" : "No"}
- Ahead: ${gitStatus.ahead} commits
- Behind: ${gitStatus.behind} commits

Stack Status (from GitHub):
- Active PRs: ${currentStack.prs.length}
- New commits ready: ${newCommits.length}
`;
    if (currentStack.prs.length > 0) {
      statusMessage += `
Active PRs (in stack order):
${currentStack.prs.map((pr, i) => `  ${i + 1}. #${pr.number}: ${pr.branch} <- ${pr.base}`).join(`
`)}`;
    }
    if (newCommits.length > 0) {
      statusMessage += `
New Commits (ready to push):
${newCommits.map((c) => `  - ${c.hash.slice(0, 7)}: ${c.message}`).join(`
`)}`;
    }
    return statusMessage;
  }
  async mergePullRequest(prNumber, mergeMethod = "squash", deleteBranch = true) {
    await this.ensurePrerequisites();
    const currentStack = await this.getCurrentStack();
    if (!prNumber) {
      if (currentStack.prs.length === 0) {
        throw new Error("No PRs found in current stack");
      }
      prNumber = currentStack.prs[currentStack.prs.length - 1].number;
    }
    const prBeingMerged = currentStack.prs.find((pr) => pr.number === prNumber);
    if (prBeingMerged && deleteBranch) {
      const dependentPRs = currentStack.prs.filter((pr) => pr.base === prBeingMerged.head && pr.number !== prNumber);
      if (dependentPRs.length > 0) {
        startGroup(`Pre-merge stack updates`, "github");
        logInfo(`Found ${dependentPRs.length} dependent PRs that need base updates before merge`);
        for (const dependentPR of dependentPRs) {
          const prBeingMergedIndex = currentStack.prs.findIndex((pr) => pr.number === prNumber);
          const config = await this.config.getAll();
          const newBase = prBeingMergedIndex > 0 ? currentStack.prs[prBeingMergedIndex - 1].head : config.defaultBranch;
          try {
            logProgress(`Updating PR #${dependentPR.number}: ${dependentPR.base} -> ${newBase}`, 1);
            await this.github.updatePullRequestBase(dependentPR.number, newBase);
            logSuccess(`Pre-updated PR #${dependentPR.number} base to avoid auto-closure`, 1);
          } catch (error) {
            logWarning(`Could not pre-update PR #${dependentPR.number} base: ${error}`, 1);
          }
        }
        endGroup();
      }
    }
    let oldBaseCommit;
    if (prBeingMerged && deleteBranch && mergeMethod === "squash") {
      const dependentPRs = currentStack.prs.filter((pr) => pr.base === prBeingMerged.head && pr.number !== prNumber);
      if (dependentPRs.length > 0) {
        oldBaseCommit = await this.git.getCommitHash(`origin/${prBeingMerged.head}`);
      }
    }
    logInfo(`Merging PR #${prNumber} using ${mergeMethod} merge...`);
    await this.github.mergePullRequest(prNumber, mergeMethod, deleteBranch);
    logSuccess(`\u2705 Successfully merged PR #${prNumber}`);
    if (prBeingMerged && deleteBranch && mergeMethod === "squash" && oldBaseCommit) {
      const dependentPRs = currentStack.prs.filter((pr) => pr.base === prBeingMerged.head && pr.number !== prNumber);
      if (dependentPRs.length > 0) {
        const config = await this.config.getAll();
        const prBeingMergedIndex = currentStack.prs.findIndex((pr) => pr.number === prNumber);
        const newBase = prBeingMergedIndex > 0 ? currentStack.prs[prBeingMergedIndex - 1].head : config.defaultBranch;
        await this.restackDependents(dependentPRs, oldBaseCommit, newBase);
      }
    }
    logInfo("\uD83D\uDD04 Updating local main with latest changes...");
    try {
      const config = await this.config.getAll();
      logInfo("  \uD83D\uDD04 Fetching from remote...");
      logInfo("  \uD83D\uDD04 Rebasing local changes...");
      await this.git.pullLatestChanges(config.defaultBranch);
      logInfo("  \u2705 Local main is now up to date");
    } catch (error) {
      const config = await this.config.getAll();
      logWarning(`  \u26A0\uFE0F Warning: Could not update local ${config.defaultBranch}: ${error}`);
    }
    logInfo("Updating stack state from GitHub...");
    await this.getCurrentStack();
    logInfo("Stack state updated successfully!");
  }
  async restackDependents(dependentPRs, oldBaseCommit, newBase) {
    if (dependentPRs.length === 0) {
      return;
    }
    startGroup(`Restacking ${dependentPRs.length} dependent branches`, "git");
    logInfo(`Rebasing dependent PRs to remove squashed commits`);
    const originalBranch = await this.git.getCurrentBranch();
    try {
      for (const pr of dependentPRs) {
        logProgress(`Restacking PR #${pr.number} (${pr.head})`, 1);
        try {
          await this.git.checkoutBranch(pr.head);
          await this.git.fetchBranch(newBase);
          await this.git.rebaseOntoTarget(`origin/${newBase}`, oldBaseCommit);
          await this.git.pushForceWithLease(pr.head);
          logSuccess(`Restacked PR #${pr.number}`, 1);
        } catch (error) {
          logWarning(`Failed to restack PR #${pr.number}: ${error}`, 1);
          try {
            await Bun.$`git rebase --abort`.quiet();
          } catch {}
        }
      }
    } finally {
      try {
        await this.git.checkoutBranch(originalBranch);
      } catch (error) {
        logWarning(`Could not return to original branch ${originalBranch}: ${error}`);
      }
    }
    endGroup();
  }
  async publishPullRequest(prNumber) {
    await this.ensurePrerequisites();
    if (!prNumber) {
      const currentStack = await this.getCurrentStack();
      if (currentStack.prs.length === 0) {
        throw new Error("No PRs found in current stack");
      }
      prNumber = currentStack.prs[currentStack.prs.length - 1].number;
    } else {
      const currentStack = await this.getCurrentStack();
      const isInStack = currentStack.prs.some((pr) => pr.number === prNumber);
      if (!isInStack) {
        console.warn(`Warning: PR #${prNumber} is not tracked in current stack, but attempting to publish anyway...`);
      }
    }
    await this.github.publishPullRequest(prNumber);
  }
  async validateSyncStatus(defaultBranch) {
    startGroup("Validating Sync Status", "git");
    try {
      logProgress("Checking sync status with remote...");
      const syncResult = await this.git.getSyncStatus(defaultBranch);
      if (syncResult.status === "clean") {
        logSuccess("Local branch is in sync with remote");
        endGroup();
        return;
      }
      const duplicateCheck = await this.git.detectDuplicateCommits(defaultBranch);
      let errorMessage = `\u274C Cannot create PR: Local branch is out of sync with remote

`;
      switch (syncResult.status) {
        case "ahead":
          if (duplicateCheck.hasDuplicates) {
            errorMessage += `Your local ${defaultBranch} has ${syncResult.aheadCount} commits that may already be merged into remote.
`;
            errorMessage += `Duplicate commit messages found:
${duplicateCheck.duplicateMessages.map((msg) => `  - ${msg}`).join(`
`)}

`;
            errorMessage += `This would create a PR with merge conflicts.

`;
            errorMessage += `To resolve:
`;
            errorMessage += `  git reset --hard origin/${defaultBranch}    # Reset to remote state
`;
            errorMessage += `  git cherry-pick <specific-commits>         # Re-apply only new commits

`;
            errorMessage += `Or:
`;
            errorMessage += `  git rebase origin/${defaultBranch}         # Rebase on top of remote

`;
          } else {
            logInfo(`Local is ${syncResult.aheadCount} commits ahead with new changes - ready to create PR`);
            endGroup();
            return;
          }
          break;
        case "behind":
          errorMessage += `Your local ${defaultBranch} is ${syncResult.behindCount} commits behind remote.
`;
          errorMessage += `To resolve:
`;
          errorMessage += `  git pull origin ${defaultBranch}            # Pull latest changes

`;
          break;
        case "diverged":
          errorMessage += `Your local ${defaultBranch} has diverged from remote:
`;
          errorMessage += `  - ${syncResult.aheadCount} commits ahead
`;
          errorMessage += `  - ${syncResult.behindCount} commits behind

`;
          errorMessage += `To resolve:
`;
          errorMessage += `  git rebase origin/${defaultBranch}          # Rebase your changes on top
`;
          errorMessage += `Or:
`;
          errorMessage += `  git reset --hard origin/${defaultBranch}    # Reset to remote (loses local changes)

`;
          break;
      }
      errorMessage += "Use --force to create PR anyway (not recommended)";
      endGroup();
      throw new Error(errorMessage);
    } catch (error) {
      endGroup();
      if (error instanceof Error && error.message.includes("Cannot create PR")) {
        throw error;
      }
      throw new Error(`Failed to validate sync status: ${error}`);
    }
  }
}

// src/cli.ts
var COMMANDS = {
  stack: "Create a new stack or add commits to existing stack",
  status: "Show current stack status",
  merge: "Merge PRs and update stack state",
  publish: "Mark PR as ready for review (remove draft status)",
  config: "Manage configuration",
  help: "Show help information"
};
var HIDDEN_COMMANDS = {
  rebase: "Rebase stack when PRs are merged"
};
async function main() {
  try {
    const { positionals, values } = parseArgs({
      args: process.argv.slice(2),
      options: {
        help: { type: "boolean", short: "h" },
        config: { type: "string", short: "c" },
        verbose: { type: "boolean", short: "v" },
        quiet: { type: "boolean", short: "q" },
        compact: { type: "boolean" },
        "output-mode": { type: "string" },
        "no-color": { type: "boolean" },
        "no-spinner": { type: "boolean" },
        "auto-publish": { type: "boolean" },
        force: { type: "boolean", short: "f" }
      },
      allowPositionals: true
    });
    const options = {
      ...values,
      autoPublish: values["auto-publish"],
      outputMode: values["output-mode"],
      noColor: values["no-color"],
      noSpinner: values["no-spinner"]
    };
    const [command, ...args] = positionals;
    if (options.help || !command || command === "help") {
      showHelp();
      return;
    }
    if (!isValidCommand(command)) {
      output.error(`Unknown command: ${command}`);
      output.info("Run 'rungs help' for available commands.");
      process.exit(1);
    }
    const config = new ConfigManager(options.config);
    const userConfig = await config.getAll();
    let outputMode = userConfig.output.mode;
    if (options.quiet || options.compact) {
      outputMode = "compact";
    } else if (options.verbose) {
      outputMode = "verbose";
    } else if (options.outputMode) {
      outputMode = options.outputMode;
    }
    setOutputMode(outputMode);
    if (options.verbose || outputMode === "verbose") {
      setVerbose(true);
    }
    const git = new GitManager;
    const github = new GitHubManager;
    const stack = new StackManager(config, git, github, outputMode);
    switch (command) {
      case "stack":
        await handlePush(stack, args, options);
        break;
      case "status":
        await handleStatus(stack, options);
        break;
      case "merge":
        await handleMerge(stack, args, options);
        break;
      case "publish":
        await handlePublish(stack, args, options);
        break;
      case "rebase":
        await handleRebase(stack, args, options);
        break;
      case "config":
        await handleConfig(config, args, options);
        break;
      default:
        output.error(`Command not implemented: ${command}`);
        process.exit(1);
    }
  } catch (error) {
    output.error(error instanceof Error ? error.message : String(error));
    if (process.argv.includes("--verbose") || process.argv.includes("-v")) {
      console.error(error);
    }
    process.exit(1);
  }
}
function isValidCommand(cmd) {
  return cmd in COMMANDS || cmd in HIDDEN_COMMANDS;
}
function showHelp() {
  console.log(`
rungs - CLI tool for managing stacked diffs with Git and GitHub

USAGE:
  rungs <command> [options]

COMMANDS:
${Object.entries(COMMANDS).map(([cmd, desc]) => `  ${cmd.padEnd(12)} ${desc}`).join(`
`)}

OPTIONS:
  -h, --help           Show help information
  -c, --config PATH    Specify config file path
  -v, --verbose        Enable verbose output mode
  -q, --quiet          Enable compact output mode (same as --compact)
      --compact        Enable compact output mode
      --output-mode    Set output mode: 'verbose' or 'compact'
      --no-color       Disable colored output
      --no-spinner     Disable spinner animations
  -f, --force          Force operation, bypassing safety checks
      --auto-publish   Create PRs as published instead of draft

EXAMPLES:
  rungs stack                      # Create/update stack with current commits
  rungs stack --auto-publish       # Create PRs as published instead of draft
  rungs stack --force              # Create PRs even if local is out of sync
  rungs publish 123                # Mark PR #123 as ready for review
  rungs publish                    # Mark top PR in stack as ready for review
  rungs status                     # Show current stack status
  rungs config set name john       # Set user name prefix for branches
  rungs help                       # Show this help

For more information, visit: https://github.com/camhahu/rungs
`);
}
async function handlePush(stack, args, options) {
  output.startSection("Push Stack Operation", "stack");
  await stack.pushStack(options.autoPublish, options.force);
  output.success("Stack operation completed successfully!");
  output.endSection();
}
async function handleStatus(stack, options) {
  const tracker = new OperationTracker(output);
  try {
    if (output.getOutputMode() === "verbose") {
      output.startSection("Stack Status", "stack");
      const status = await stack.getStatus();
      console.log(status);
      output.endSection();
      return;
    }
    const stackState = await tracker.stackOperation("Retrieving stack status", async () => {
      return await stack.getCurrentStack();
    }, {
      successMessage: (result) => `Stack status retrieved - ${result.prs.length} PRs, ${result.totalCommits} commits`,
      showElapsed: true
    });
    if (stackState.prs.length > 0) {
      console.log(`Stack Status: ${stackState.prs.length} PRs, ${stackState.totalCommits} commits`);
      stackState.prs.forEach((pr, i) => {
        console.log(`  ${i + 1}. #${pr.number}: ${pr.branch} <- ${pr.base}`);
      });
    } else {
      console.log("Stack Status: No active PRs");
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    output.error(`Failed to get stack status: ${errorMessage}`);
    process.exit(1);
  }
}
async function handlePublish(stack, args, options) {
  const [prNumberStr] = args;
  output.startSection("Publish Pull Request", "github");
  if (prNumberStr) {
    const prNumber = parseInt(prNumberStr);
    if (isNaN(prNumber)) {
      output.error("PR number must be a valid integer");
      process.exit(1);
    }
    output.progress(`Publishing PR #${prNumber}...`);
    await stack.publishPullRequest(prNumber);
    output.success(`Successfully published PR #${prNumber}`);
  } else {
    output.progress("Publishing top PR in stack...");
    await stack.publishPullRequest();
    output.success("Successfully published top PR in stack");
  }
  output.endSection();
}
async function handleMerge(stack, args, options) {
  const [prNumberStr, ...flags] = args;
  let mergeMethod = "squash";
  let deleteBranch = true;
  for (const flag of flags) {
    switch (flag) {
      case "--squash":
        mergeMethod = "squash";
        break;
      case "--merge":
        mergeMethod = "merge";
        break;
      case "--rebase":
        mergeMethod = "rebase";
        break;
      case "--no-delete-branch":
        deleteBranch = false;
        break;
      case "--delete-branch":
        deleteBranch = true;
        break;
    }
  }
  const prNumber = prNumberStr ? parseInt(prNumberStr) : undefined;
  if (prNumberStr && isNaN(prNumber)) {
    output.error("PR number must be a valid integer");
    process.exit(1);
  }
  output.startSection("Merge Pull Request", "github");
  await stack.mergePullRequest(prNumber, mergeMethod, deleteBranch);
  output.endSection();
}
async function handleRebase(stack, args, options) {
  output.startSection("Rebase Stack", "stack");
  output.info("The new GitHub-first stack manager automatically fixes broken chains.");
  output.info("Stack bases are updated automatically when you run 'rungs status' or 'rungs stack'.");
  output.info("Manual rebase is no longer needed!");
  output.endSection();
}
async function handleConfig(config, args, options) {
  const [action, key, value] = args;
  output.startSection("Configuration", "config");
  if (action === "set" && key && value) {
    await config.set(key, value);
    output.success(`Set ${key} = ${value}`);
  } else if (action === "get" && key) {
    const val = await config.get(key);
    output.info(`${key} = ${val ?? "undefined"}`);
  } else if (action === "list" || !action) {
    const allConfig = await config.getAll();
    const configItems = Object.entries(allConfig).map(([k, v]) => ({
      label: k,
      value: v
    }));
    logSummary("Current Configuration", configItems);
  } else {
    output.error("Usage: rungs config [set <key> <value> | get <key> | list]");
    process.exit(1);
  }
  output.endSection();
}
if (import.meta.main) {
  main();
}
