#!/usr/bin/env bun
// @bun

// src/cli.ts
import { parseArgs } from "util";

// src/git-manager.ts
class GitManager {
  async getCurrentBranch() {
    const result = await Bun.$`git rev-parse --abbrev-ref HEAD`.text();
    return result.trim();
  }
  async isGitRepo() {
    try {
      await Bun.$`git rev-parse --git-dir`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async getStatus() {
    const currentBranch = await this.getCurrentBranch();
    const statusResult = await Bun.$`git status --porcelain`.text();
    const isClean = statusResult.trim() === "";
    let ahead = 0;
    let behind = 0;
    try {
      const aheadResult = await Bun.$`git rev-list --count HEAD..origin/${currentBranch}`.text();
      behind = parseInt(aheadResult.trim()) || 0;
      const behindResult = await Bun.$`git rev-list --count origin/${currentBranch}..HEAD`.text();
      ahead = parseInt(behindResult.trim()) || 0;
    } catch {}
    return {
      currentBranch,
      isClean,
      ahead,
      behind
    };
  }
  async getCommitsSince(baseBranch) {
    try {
      const result = await Bun.$`git log ${baseBranch}..HEAD '--pretty=format:%H|%s|%an|%ad' --date=iso`.text();
      if (!result.trim()) {
        return [];
      }
      return result.trim().split(`
`).map((line) => {
        const [hash, message, author, date] = line.split("|");
        return { hash, message, author, date };
      });
    } catch (error) {
      console.error(`Git command failed for ${baseBranch}:`);
      console.error(error);
      throw new Error(`Failed to get commits since ${baseBranch}: ${error}`);
    }
  }
  async fetchOrigin() {
    try {
      await Bun.$`git fetch origin`;
    } catch (error) {
      throw new Error(`Failed to fetch from origin: ${error}`);
    }
  }
  async rebaseOnto(targetBranch) {
    try {
      await Bun.$`git rebase origin/${targetBranch}`;
    } catch (error) {
      try {
        await Bun.$`git rebase --abort`;
      } catch {}
      throw new Error(`Failed to rebase onto ${targetBranch}. Please resolve conflicts manually.`);
    }
  }
  async createBranch(branchName, fromCommit) {
    try {
      if (fromCommit) {
        await Bun.$`git checkout -b ${branchName} ${fromCommit}`;
      } else {
        await Bun.$`git checkout -b ${branchName}`;
      }
    } catch (error) {
      throw new Error(`Failed to create branch ${branchName}: ${error}`);
    }
  }
  async checkoutBranch(branchName) {
    try {
      await Bun.$`git checkout ${branchName}`;
    } catch (error) {
      throw new Error(`Failed to checkout branch ${branchName}: ${error}`);
    }
  }
  async branchExists(branchName) {
    try {
      await Bun.$`git rev-parse --verify ${branchName}`;
      return true;
    } catch {
      return false;
    }
  }
  async pushBranch(branchName, force = false) {
    try {
      const forceFlag = force ? "--force-with-lease" : "";
      if (force) {
        await Bun.$`git push origin ${branchName} --force-with-lease`;
      } else {
        await Bun.$`git push origin ${branchName}`;
      }
    } catch (error) {
      throw new Error(`Failed to push branch ${branchName}: ${error}`);
    }
  }
  async getRemoteUrl() {
    try {
      const result = await Bun.$`git remote get-url origin`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get remote URL: ${error}`);
    }
  }
  async getCommitMessage(hash) {
    try {
      const result = await Bun.$`git log -1 --pretty=format:"%s" ${hash}`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get commit message for ${hash}: ${error}`);
    }
  }
  generateBranchName(commits, userPrefix, strategy) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
    switch (strategy) {
      case "timestamp":
        return `${userPrefix}/${timestamp}`;
      case "sequential":
        return `${userPrefix}/stack-${Date.now()}`;
      case "commit-message":
      default:
        if (commits.length === 0) {
          return `${userPrefix}/empty-${timestamp}`;
        }
        const firstCommit = commits[0];
        const cleanMessage = firstCommit.message.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").slice(0, 50);
        const fullBranchName = `${userPrefix}/${cleanMessage}`;
        if (fullBranchName.length > 63) {
          const availableLength = 63 - userPrefix.length - 1;
          const truncatedMessage = cleanMessage.slice(0, availableLength);
          return `${userPrefix}/${truncatedMessage}`;
        }
        return fullBranchName;
    }
  }
}

// src/github-manager.ts
class GitHubManager {
  async isGitHubCLIAvailable() {
    try {
      await Bun.$`gh --version`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async isAuthenticated() {
    try {
      await Bun.$`gh auth status`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async getRepoInfo() {
    try {
      const result = await Bun.$`gh repo view --json owner,name`.text();
      const data = JSON.parse(result);
      return {
        owner: data.owner.login,
        repo: data.name
      };
    } catch (error) {
      throw new Error(`Failed to get repository info: ${error}`);
    }
  }
  async createPullRequest(title, body, head, base, draft = true) {
    try {
      const bodyFile = `/tmp/rungs-pr-body-${Date.now()}.txt`;
      await Bun.write(bodyFile, body);
      try {
        const args = ["gh", "pr", "create", "--title", title, "--body-file", bodyFile, "--head", head, "--base", base];
        if (draft) {
          args.push("--draft");
        }
        const prUrl = await Bun.$`${args}`.text();
        const prNumber = parseInt(prUrl.trim().split("/").pop() || "0");
        return {
          number: prNumber,
          title,
          body,
          url: prUrl.trim(),
          draft,
          head,
          base
        };
      } finally {
        try {
          await Bun.$`rm ${bodyFile}`.quiet();
        } catch {}
      }
    } catch (error) {
      let errorMessage = "Failed to create pull request";
      if (error.stderr) {
        errorMessage += `: ${error.stderr.toString().trim()}`;
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      } else {
        errorMessage += `: ${error}`;
      }
      if (error.stderr?.includes("remote ref does not exist") || head.length > 63) {
        errorMessage += `

Hint: Branch name may be too long. GitHub branch names must be 63 characters or less.`;
      }
      throw new Error(errorMessage);
    }
  }
  async updatePullRequest(prNumber, title, body) {
    try {
      const args = [];
      if (title) {
        args.push("--title", title);
      }
      if (body) {
        args.push("--body", body);
      }
      if (args.length > 0) {
        await Bun.$`gh pr edit ${prNumber} ${args}`;
      }
    } catch (error) {
      throw new Error(`Failed to update pull request #${prNumber}: ${error}`);
    }
  }
  async updatePullRequestBase(prNumber, newBase) {
    try {
      await Bun.$`gh pr edit ${prNumber} --base ${newBase}`;
    } catch (error) {
      throw new Error(`Failed to update pull request #${prNumber} base to ${newBase}: ${error}`);
    }
  }
  async mergePullRequest(prNumber, mergeMethod = "squash", deleteBranch = true) {
    try {
      const args = ["gh", "pr", "merge", prNumber.toString()];
      switch (mergeMethod) {
        case "squash":
          args.push("--squash");
          break;
        case "merge":
          args.push("--merge");
          break;
        case "rebase":
          args.push("--rebase");
          break;
      }
      if (deleteBranch) {
        args.push("--delete-branch");
      }
      await Bun.$`${args}`;
    } catch (error) {
      let errorMessage = `Failed to merge PR #${prNumber}`;
      if (error.stderr) {
        errorMessage += `: ${error.stderr.toString().trim()}`;
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      }
      throw new Error(errorMessage);
    }
  }
  async getPullRequest(branchName) {
    try {
      const result = await Bun.$`gh pr view ${branchName} --json number,title,body,url,isDraft,headRefName,baseRefName`.text();
      const data = JSON.parse(result);
      return {
        number: data.number,
        title: data.title,
        body: data.body,
        url: data.url,
        draft: data.isDraft,
        head: data.headRefName,
        base: data.baseRefName
      };
    } catch {
      return null;
    }
  }
  async getPullRequestByNumber(prNumber) {
    try {
      const result = await Bun.$`gh pr view ${prNumber} --json number,title,body,url,isDraft,headRefName,baseRefName`.text();
      const data = JSON.parse(result);
      return {
        number: data.number,
        title: data.title,
        body: data.body,
        url: data.url,
        draft: data.isDraft,
        head: data.headRefName,
        base: data.baseRefName
      };
    } catch {
      return null;
    }
  }
  async getPullRequestStatus(prNumber) {
    try {
      const result = await Bun.$`gh pr view ${prNumber} --json state`.text();
      const data = JSON.parse(result);
      return data.state.toLowerCase();
    } catch {
      return null;
    }
  }
  async listPullRequests(head) {
    try {
      let cmd = "gh pr list --json number,title,body,url,draft,headRefName,baseRefName";
      if (head) {
        cmd += ` --head ${head}`;
      }
      const result = await Bun.$`${cmd}`.text();
      const data = JSON.parse(result);
      return data.map((pr) => ({
        number: pr.number,
        title: pr.title,
        body: pr.body,
        url: pr.url,
        draft: pr.draft,
        head: pr.headRefName,
        base: pr.baseRefName
      }));
    } catch (error) {
      throw new Error(`Failed to list pull requests: ${error}`);
    }
  }
  async closePullRequest(prNumber) {
    try {
      await Bun.$`gh pr close ${prNumber}`;
    } catch (error) {
      throw new Error(`Failed to close pull request #${prNumber}: ${error}`);
    }
  }
  async publishPullRequest(prNumber) {
    try {
      await Bun.$`gh pr ready ${prNumber}`;
    } catch (error) {
      let errorMessage = `Failed to publish pull request #${prNumber}`;
      if (error.stderr) {
        const stderr = error.stderr.toString().trim();
        errorMessage += `: ${stderr}`;
        if (stderr.includes("not a draft")) {
          errorMessage += `

Hint: This PR is already published (not a draft).`;
        } else if (stderr.includes("not found")) {
          errorMessage += `

Hint: PR number may not exist or you may not have access to it.`;
        }
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      }
      throw new Error(errorMessage);
    }
  }
  generatePRTitle(commits) {
    if (commits.length === 0) {
      return "Empty stack";
    }
    if (commits.length === 1) {
      return commits[0].message;
    }
    return `${commits[0].message} (+${commits.length - 1} more)`;
  }
  generatePRBody(commits) {
    if (commits.length === 0) {
      return "Empty stack - no commits to include.";
    }
    if (commits.length === 1) {
      return `Single commit stack:

- ${commits[0].message}`;
    }
    const commitList = commits.map((commit) => `- ${commit.message}`).join(`
`);
    return `Stack of ${commits.length} commits:

${commitList}`;
  }
}

// src/config-manager.ts
import { join } from "path";
import { homedir } from "os";
var DEFAULT_CONFIG = {
  userPrefix: "dev",
  defaultBranch: "main",
  draftPRs: true,
  autoRebase: true,
  branchNaming: "commit-message"
};

class ConfigManager {
  configPath;
  constructor(customPath) {
    this.configPath = customPath || join(homedir(), ".rungs", "config.json");
  }
  async ensureConfigDir() {
    const configDir = this.configPath.split("/").slice(0, -1).join("/");
    try {
      await Bun.$`mkdir -p ${configDir}`;
    } catch (error) {
      throw new Error(`Failed to create config directory: ${error}`);
    }
  }
  async getAll() {
    try {
      const file = Bun.file(this.configPath);
      if (!await file.exists()) {
        return DEFAULT_CONFIG;
      }
      const content = await file.text();
      const config = JSON.parse(content);
      return { ...DEFAULT_CONFIG, ...config };
    } catch (error) {
      console.warn(`Failed to read config file, using defaults: ${error}`);
      return DEFAULT_CONFIG;
    }
  }
  async get(key) {
    const config = await this.getAll();
    return config[key];
  }
  async set(key, value) {
    await this.ensureConfigDir();
    const config = await this.getAll();
    config[key] = value;
    try {
      await Bun.write(this.configPath, JSON.stringify(config, null, 2));
    } catch (error) {
      throw new Error(`Failed to write config file: ${error}`);
    }
  }
  async update(updates) {
    await this.ensureConfigDir();
    const config = await this.getAll();
    const newConfig = { ...config, ...updates };
    try {
      await Bun.write(this.configPath, JSON.stringify(newConfig, null, 2));
    } catch (error) {
      throw new Error(`Failed to update config file: ${error}`);
    }
  }
  async reset() {
    await this.ensureConfigDir();
    try {
      await Bun.write(this.configPath, JSON.stringify(DEFAULT_CONFIG, null, 2));
    } catch (error) {
      throw new Error(`Failed to reset config file: ${error}`);
    }
  }
}

// src/output-manager.ts
class OutputManager {
  indentLevel = 0;
  currentSection = null;
  config;
  static ICONS = {
    git: "\uD83D\uDD04",
    github: "\uD83D\uDCE4",
    stack: "\uD83D\uDCDA",
    config: "\u2699\uFE0F",
    general: "\uD83D\uDCBB",
    success: "\u2705",
    error: "\u274C",
    warning: "\u26A0\uFE0F",
    info: "\u2139\uFE0F",
    progress: "\uD83D\uDD04"
  };
  static COLORS = {
    reset: "\x1B[0m",
    bright: "\x1B[1m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    gray: "\x1B[90m"
  };
  constructor(config = {}) {
    this.config = {
      showTimestamps: false,
      useColors: true,
      verboseMode: false,
      ...config
    };
  }
  startSection(title, type = "general") {
    if (this.currentSection) {
      this.endSection();
    }
    const icon = OutputManager.ICONS[type];
    const separator = "\u2550".repeat(Math.max(20, title.length + 10));
    console.log();
    console.log(this.colorize(`${separator}`, "cyan"));
    console.log(this.colorize(`${icon} ${title.toUpperCase()}`, "bright"));
    console.log(this.colorize(`${separator}`, "cyan"));
    console.log();
    this.currentSection = title;
    this.indentLevel = 0;
  }
  endSection() {
    if (!this.currentSection)
      return;
    console.log();
    console.log(this.colorize("\u2550".repeat(30), "cyan"));
    console.log();
    this.currentSection = null;
    this.indentLevel = 0;
  }
  log(message, level = "info", indent = 0) {
    const icon = OutputManager.ICONS[level];
    const prefix = this.getPrefix(icon, level);
    const indentation = "  ".repeat(this.indentLevel + indent);
    const formattedMessage = `${indentation}${prefix} ${message}`;
    console.log(this.colorize(formattedMessage, this.getLevelColor(level)));
  }
  progress(message, indent = 0) {
    this.log(message, "progress", indent);
  }
  success(message, indent = 0) {
    this.log(message, "success", indent);
  }
  error(message, indent = 0) {
    this.log(message, "error", indent);
  }
  warning(message, indent = 0) {
    this.log(message, "warning", indent);
  }
  info(message, indent = 0) {
    this.log(message, "info", indent);
  }
  startGroup(title, type = "general") {
    const icon = OutputManager.ICONS[type];
    const indentation = "  ".repeat(this.indentLevel);
    console.log();
    console.log(this.colorize(`${indentation}${icon} ${title}:`, "bright"));
    this.indentLevel++;
  }
  endGroup() {
    if (this.indentLevel > 0) {
      this.indentLevel--;
    }
    console.log();
  }
  logList(items, title, level = "info") {
    if (title) {
      this.log(title, level);
    }
    items.forEach((item) => {
      const indentation = "  ".repeat(this.indentLevel + 1);
      console.log(this.colorize(`${indentation}- ${item}`, this.getLevelColor(level)));
    });
  }
  logCommand(command) {
    if (this.config.verboseMode) {
      const indentation = "  ".repeat(this.indentLevel);
      console.log(this.colorize(`${indentation}$ ${command}`, "gray"));
    }
  }
  summary(title, items) {
    console.log();
    console.log(this.colorize(`\uD83D\uDCCB ${title}:`, "bright"));
    const maxLabelLength = Math.max(...items.map((item) => item.label.length));
    items.forEach((item) => {
      const paddedLabel = item.label.padEnd(maxLabelLength);
      const indentation = "  ".repeat(this.indentLevel + 1);
      console.log(this.colorize(`${indentation}${paddedLabel}: ${item.value}`, "info"));
    });
    console.log();
  }
  separator(char = "\u2500", length = 40) {
    const indentation = "  ".repeat(this.indentLevel);
    console.log(this.colorize(`${indentation}${char.repeat(length)}`, "gray"));
  }
  setVerbose(verbose) {
    this.config.verboseMode = verbose;
  }
  getPrefix(icon, level) {
    if (this.config.showTimestamps) {
      const timestamp = new Date().toLocaleTimeString();
      return `[${timestamp}] ${icon}`;
    }
    return icon;
  }
  getLevelColor(level) {
    switch (level) {
      case "success":
        return "green";
      case "error":
        return "red";
      case "warning":
        return "yellow";
      case "progress":
        return "cyan";
      case "info":
      default:
        return "reset";
    }
  }
  colorize(text, color) {
    if (!this.config.useColors) {
      return text;
    }
    const colorCode = OutputManager.COLORS[color];
    if (!colorCode) {
      return text;
    }
    return `${colorCode}${text}${OutputManager.COLORS.reset}`;
  }
}
var output = new OutputManager;
function logProgress(message, indent = 0) {
  output.progress(message, indent);
}
function logSuccess(message, indent = 0) {
  output.success(message, indent);
}
function logWarning(message, indent = 0) {
  output.warning(message, indent);
}
function logInfo(message, indent = 0) {
  output.info(message, indent);
}
function startGroup(title, type = "general") {
  output.startGroup(title, type);
}
function endGroup() {
  output.endGroup();
}
function logSummary(title, items) {
  output.summary(title, items);
}
function setVerbose(verbose) {
  output.setVerbose(verbose);
}

// src/stack-manager.ts
class StackManager {
  config;
  git;
  github;
  stateFile;
  constructor(config, git, github) {
    this.config = config;
    this.git = git;
    this.github = github;
    this.stateFile = ".rungs-state.json";
  }
  async ensurePrerequisites() {
    if (!await this.git.isGitRepo()) {
      throw new Error("Not in a git repository. Run 'git init' to initialize a repository.");
    }
    if (!await this.github.isGitHubCLIAvailable()) {
      throw new Error("GitHub CLI (gh) is not installed or not in PATH. Install from https://cli.github.com/");
    }
    if (!await this.github.isAuthenticated()) {
      throw new Error("Not authenticated with GitHub CLI. Run 'gh auth login' to authenticate.");
    }
    await this.syncWithGitHub();
  }
  async syncWithGitHub() {
    const state = await this.loadState();
    if (state.pullRequests.length === 0) {
      return;
    }
    startGroup("Syncing with GitHub", "github");
    const config = await this.config.getAll();
    const activePRs = [];
    const activeBranches = [];
    const mergedPRs = [];
    const needsRebase = [];
    logProgress("Checking PR status and bases...");
    for (let i = 0;i < state.pullRequests.length; i++) {
      const prNumber = state.pullRequests[i];
      const branchName = state.branches[i];
      try {
        const status = await this.github.getPullRequestStatus(prNumber);
        if (status === "open") {
          const prDetails = await this.github.getPullRequestByNumber(prNumber);
          const expectedBase = i === 0 ? config.defaultBranch : state.branches[i - 1];
          logInfo(`PR #${prNumber}: current base="${prDetails?.base}", expected base="${expectedBase}"`, 1);
          if (prDetails && prDetails.base !== expectedBase) {
            const baseExists = await this.branchExistsOnGitHub(prDetails.base);
            logInfo(`Base branch "${prDetails.base}" exists: ${baseExists}`, 1);
            if (!baseExists || prDetails.base !== expectedBase) {
              logInfo(`Adding PR #${prNumber} to rebase queue`, 1);
              needsRebase.push({ prNumber, branchName, correctBase: expectedBase });
            }
          }
          activePRs.push(prNumber);
          activeBranches.push(branchName);
        } else if (status === "merged") {
          mergedPRs.push(prNumber);
        }
      } catch (error) {
        logWarning(`Could not check status of PR #${prNumber}, removing from tracking`, 1);
      }
    }
    if (mergedPRs.length > 0 && activePRs.length > 0) {
      await this.autoRebaseAfterMerges(activePRs, activeBranches);
    }
    if (needsRebase.length > 0) {
      await this.fixIncorrectBases(needsRebase);
    }
    const syncedState = {
      ...state,
      pullRequests: activePRs,
      branches: activeBranches,
      lastBranch: activeBranches.length > 0 ? activeBranches[activeBranches.length - 1] : undefined
    };
    await this.saveState(syncedState);
    logSuccess("GitHub sync completed");
    endGroup();
  }
  async branchExistsOnGitHub(branchName) {
    try {
      await Bun.$`gh api repos/:owner/:repo/branches/${branchName}`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async fixIncorrectBases(needsRebase) {
    startGroup(`Fixing Incorrect Bases (${needsRebase.length} PRs)`, "github");
    for (const { prNumber, branchName, correctBase } of needsRebase) {
      try {
        logProgress(`Updating PR #${prNumber} (${branchName}) base to ${correctBase}`, 1);
        await this.github.updatePullRequestBase(prNumber, correctBase);
        logSuccess(`Updated PR #${prNumber} base`, 1);
      } catch (error) {
        logWarning(`Could not update base for PR #${prNumber}: ${error}`, 1);
      }
    }
    endGroup();
  }
  async autoRebaseAfterMerges(activePRs, activeBranches) {
    const config = await this.config.getAll();
    console.log(`Auto-rebasing ${activePRs.length} PRs after merge...`);
    for (let i = 0;i < activePRs.length; i++) {
      const prNumber = activePRs[i];
      const newBase = i === 0 ? config.defaultBranch : activeBranches[i - 1];
      try {
        console.log(`Updating PR #${prNumber} base to ${newBase}`);
        await this.github.updatePullRequestBase(prNumber, newBase);
      } catch (error) {
        console.warn(`Warning: Could not update base for PR #${prNumber}: ${error}`);
      }
    }
  }
  async loadState() {
    try {
      const file = Bun.file(this.stateFile);
      if (!await file.exists()) {
        return { branches: [], pullRequests: [] };
      }
      const content = await file.text();
      const state = JSON.parse(content);
      return { branches: [], pullRequests: [], ...state };
    } catch {
      return { branches: [], pullRequests: [] };
    }
  }
  async saveState(state) {
    try {
      await Bun.write(this.stateFile, JSON.stringify(state, null, 2));
    } catch (error) {
      throw new Error(`Failed to save state: ${error}`);
    }
  }
  async mergePullRequest(prNumber, mergeMethod = "squash", deleteBranch = true) {
    await this.ensurePrerequisites();
    if (!prNumber) {
      const state = await this.loadState();
      if (state.pullRequests.length === 0) {
        throw new Error("No PRs found in current stack");
      }
      prNumber = state.pullRequests[state.pullRequests.length - 1];
    }
    console.log(`Merging PR #${prNumber} using ${mergeMethod} merge...`);
    await this.github.mergePullRequest(prNumber, mergeMethod, deleteBranch);
    console.log(`\u2705 Successfully merged PR #${prNumber}`);
    console.log("Updating stack state...");
    await this.syncWithGitHub();
    console.log("Stack state updated successfully!");
  }
  async pushStack(autoPublish = false) {
    await this.ensurePrerequisites();
    const config = await this.config.getAll();
    const currentBranch = await this.git.getCurrentBranch();
    if (currentBranch !== config.defaultBranch) {
      throw new Error(`Must be on ${config.defaultBranch} branch to push stack. Currently on ${currentBranch}.`);
    }
    const status = await this.git.getStatus();
    if (!status.isClean) {
      throw new Error("Working directory is not clean. Please commit or stash changes.");
    }
    if (config.autoRebase) {
      startGroup("Fetching Latest Changes", "git");
      logProgress("Fetching from origin...");
      await this.git.fetchOrigin();
      logSuccess("Fetched latest changes");
      if (status.behind > 0) {
        logProgress(`Rebasing ${status.behind} commits...`);
        await this.git.rebaseOnto(config.defaultBranch);
        logSuccess("Rebase completed");
      }
      endGroup();
    }
    const state = await this.loadState();
    let baseRef;
    if (state.lastProcessedCommit) {
      baseRef = state.lastProcessedCommit;
    } else {
      try {
        await Bun.$`git rev-parse --verify origin/${config.defaultBranch}`.quiet();
        baseRef = `origin/${config.defaultBranch}`;
      } catch {
        try {
          const rootCommit = await Bun.$`git rev-list --max-parents=0 HEAD`.text();
          baseRef = rootCommit.trim();
        } catch {
          baseRef = `HEAD~10`;
        }
      }
    }
    const newCommits = await this.git.getCommitsSince(baseRef);
    if (newCommits.length === 0) {
      logInfo("No new commits to process.");
      return;
    }
    startGroup("Processing Commits", "git");
    logInfo(`Found ${newCommits.length} new commits to process.`);
    const commitList = newCommits.map((c) => `${c.hash.slice(0, 7)}: ${c.message}`);
    output.logList(commitList, "Commits to process:", "info");
    endGroup();
    const branchName = this.git.generateBranchName(newCommits, config.userPrefix, config.branchNaming);
    if (await this.git.branchExists(branchName)) {
      throw new Error(`Branch ${branchName} already exists. Please delete it or use a different naming strategy.`);
    }
    startGroup("Creating Branch", "git");
    logProgress(`Creating branch: ${branchName}`);
    await this.git.createBranch(branchName);
    logProgress("Pushing branch to remote...");
    await this.git.pushBranch(branchName);
    logSuccess("Branch created and pushed");
    endGroup();
    startGroup("Creating Pull Request", "github");
    const prTitle = this.github.generatePRTitle(newCommits);
    const prBody = this.github.generatePRBody(newCommits);
    const baseBranch = state.lastBranch || config.defaultBranch;
    logProgress(`Creating PR: "${prTitle}"`);
    logInfo(`Base branch: ${baseBranch}`, 1);
    logInfo(`Draft mode: ${autoPublish ? "No (published)" : "Yes"}`, 1);
    const isDraft = autoPublish ? false : config.draftPRs;
    const pr = await this.github.createPullRequest(prTitle, prBody, branchName, baseBranch, isDraft);
    logSuccess(`Created pull request: ${pr.url}`);
    endGroup();
    startGroup("Finalizing", "stack");
    logProgress("Switching back to main branch...");
    await this.git.checkoutBranch(config.defaultBranch);
    logProgress("Updating stack state...");
    const newState = {
      lastProcessedCommit: newCommits[0].hash,
      branches: [...state.branches, branchName],
      pullRequests: [...state.pullRequests, pr.number],
      lastBranch: branchName
    };
    await this.saveState(newState);
    logSuccess("Stack state updated");
    endGroup();
    logSummary("Stack Created Successfully", [
      { label: "Branch", value: branchName },
      { label: "Pull Request", value: `#${pr.number}` },
      { label: "URL", value: pr.url }
    ]);
    logInfo(`You can now continue working on ${config.defaultBranch} and run 'rungs push' again for additional commits.`);
  }
  async getStatus() {
    await this.ensurePrerequisites();
    const config = await this.config.getAll();
    const gitStatus = await this.git.getStatus();
    const state = await this.loadState();
    let baseRef;
    if (state.lastProcessedCommit && state.pullRequests.length > 0) {
      baseRef = state.lastProcessedCommit;
    } else {
      try {
        await Bun.$`git rev-parse --verify origin/${config.defaultBranch}`.quiet();
        baseRef = `origin/${config.defaultBranch}`;
      } catch {
        try {
          const rootCommit = await Bun.$`git rev-list --max-parents=0 HEAD`.text();
          baseRef = rootCommit.trim();
        } catch {
          baseRef = `HEAD~10`;
        }
      }
    }
    const newCommits = await this.git.getCommitsSince(baseRef);
    let statusMessage = `
Current Status:
- Branch: ${gitStatus.currentBranch}
- Clean: ${gitStatus.isClean ? "Yes" : "No"}
- Ahead: ${gitStatus.ahead} commits
- Behind: ${gitStatus.behind} commits

Stack Status:
- Active branches: ${state.branches.length}
- Active PRs: ${state.pullRequests.length}
- New commits ready: ${newCommits.length}
`;
    if (state.branches.length > 0) {
      statusMessage += `
Active Branches:
${state.branches.map((b) => `  - ${b}`).join(`
`)}`;
    }
    if (state.pullRequests.length > 0) {
      statusMessage += `
Active PRs:
${state.pullRequests.map((pr) => `  - #${pr}`).join(`
`)}`;
    }
    if (newCommits.length > 0) {
      statusMessage += `
New Commits (ready to push):
${newCommits.map((c) => `  - ${c.hash.slice(0, 7)}: ${c.message}`).join(`
`)}`;
    }
    return statusMessage;
  }
  async rebaseStack(mergedPrNumber) {
    await this.ensurePrerequisites();
    const state = await this.loadState();
    const mergedPrIndex = state.pullRequests.indexOf(mergedPrNumber);
    if (mergedPrIndex === -1) {
      throw new Error(`PR #${mergedPrNumber} not found in active stack`);
    }
    const mergedBranch = state.branches[mergedPrIndex];
    for (let i = mergedPrIndex + 1;i < state.pullRequests.length; i++) {
      const prNumber = state.pullRequests[i];
      const newBase = i === mergedPrIndex + 1 ? "main" : state.branches[i - 1];
      console.log(`Updating PR #${prNumber} base to ${newBase}`);
      await this.github.updatePullRequestBase(prNumber, newBase);
    }
    const newState = {
      ...state,
      branches: state.branches.filter((_, index) => index !== mergedPrIndex),
      pullRequests: state.pullRequests.filter((_, index) => index !== mergedPrIndex),
      lastBranch: mergedPrIndex === 0 ? undefined : state.branches[mergedPrIndex - 1]
    };
    await this.saveState(newState);
    console.log(`Removed merged PR #${mergedPrNumber} and updated stack bases`);
  }
  async publishPullRequest(prNumber) {
    await this.ensurePrerequisites();
    if (!prNumber) {
      const state2 = await this.loadState();
      if (state2.pullRequests.length === 0) {
        throw new Error("No PRs found in current stack");
      }
      prNumber = state2.pullRequests[state2.pullRequests.length - 1];
    }
    const state = await this.loadState();
    if (!state.pullRequests.includes(prNumber)) {
      console.warn(`Warning: PR #${prNumber} is not tracked in current stack, but attempting to publish anyway...`);
    }
    await this.github.publishPullRequest(prNumber);
  }
}

// src/cli.ts
var COMMANDS = {
  push: "Create a new stack or add commits to existing stack",
  status: "Show current stack status",
  merge: "Merge PRs and update stack state",
  publish: "Mark PR as ready for review (remove draft status)",
  config: "Manage configuration",
  help: "Show help information"
};
var HIDDEN_COMMANDS = {
  rebase: "Rebase stack when PRs are merged"
};
async function main() {
  try {
    const { positionals, values } = parseArgs({
      args: process.argv.slice(2),
      options: {
        help: { type: "boolean", short: "h" },
        config: { type: "string", short: "c" },
        verbose: { type: "boolean", short: "v" },
        "auto-publish": { type: "boolean" }
      },
      allowPositionals: true
    });
    const options = {
      ...values,
      autoPublish: values["auto-publish"]
    };
    const [command, ...args] = positionals;
    if (options.help || !command || command === "help") {
      showHelp();
      return;
    }
    if (!isValidCommand(command)) {
      output.error(`Unknown command: ${command}`);
      output.info("Run 'rungs help' for available commands.");
      process.exit(1);
    }
    if (options.verbose) {
      setVerbose(true);
    }
    const config = new ConfigManager(options.config);
    const git = new GitManager;
    const github = new GitHubManager;
    const stack = new StackManager(config, git, github);
    switch (command) {
      case "push":
        await handlePush(stack, args, options);
        break;
      case "status":
        await handleStatus(stack, options);
        break;
      case "merge":
        await handleMerge(stack, args, options);
        break;
      case "publish":
        await handlePublish(stack, args, options);
        break;
      case "rebase":
        await handleRebase(stack, args, options);
        break;
      case "config":
        await handleConfig(config, args, options);
        break;
      default:
        output.error(`Command not implemented: ${command}`);
        process.exit(1);
    }
  } catch (error) {
    output.error(error instanceof Error ? error.message : String(error));
    if (process.argv.includes("--verbose") || process.argv.includes("-v")) {
      console.error(error);
    }
    process.exit(1);
  }
}
function isValidCommand(cmd) {
  return cmd in COMMANDS || cmd in HIDDEN_COMMANDS;
}
function showHelp() {
  console.log(`
rungs - CLI tool for managing stacked diffs with Git and GitHub

USAGE:
  rungs <command> [options]

COMMANDS:
${Object.entries(COMMANDS).map(([cmd, desc]) => `  ${cmd.padEnd(12)} ${desc}`).join(`
`)}

OPTIONS:
  -h, --help         Show help information
  -c, --config PATH  Specify config file path
  -v, --verbose      Enable verbose output
      --auto-publish Create PRs as published instead of draft

EXAMPLES:
  rungs push                       # Create/update stack with current commits
  rungs push --auto-publish        # Create PRs as published instead of draft
  rungs publish 123                # Mark PR #123 as ready for review
  rungs publish                    # Mark top PR in stack as ready for review
  rungs status                     # Show current stack status
  rungs config set name john       # Set user name prefix for branches
  rungs help                       # Show this help

For more information, visit: https://github.com/camhahu/rungs
`);
}
async function handlePush(stack, args, options) {
  output.startSection("Push Stack Operation", "stack");
  await stack.pushStack(options.autoPublish);
  output.success("Stack operation completed successfully!");
  output.endSection();
}
async function handleStatus(stack, options) {
  output.startSection("Stack Status", "stack");
  const status = await stack.getStatus();
  console.log(status);
  output.endSection();
}
async function handlePublish(stack, args, options) {
  const [prNumberStr] = args;
  output.startSection("Publish Pull Request", "github");
  if (prNumberStr) {
    const prNumber = parseInt(prNumberStr);
    if (isNaN(prNumber)) {
      output.error("PR number must be a valid integer");
      process.exit(1);
    }
    output.progress(`Publishing PR #${prNumber}...`);
    await stack.publishPullRequest(prNumber);
    output.success(`Successfully published PR #${prNumber}`);
  } else {
    output.progress("Publishing top PR in stack...");
    await stack.publishPullRequest();
    output.success("Successfully published top PR in stack");
  }
  output.endSection();
}
async function handleMerge(stack, args, options) {
  const [prNumberStr, ...flags] = args;
  let mergeMethod = "squash";
  let deleteBranch = true;
  for (const flag of flags) {
    switch (flag) {
      case "--squash":
        mergeMethod = "squash";
        break;
      case "--merge":
        mergeMethod = "merge";
        break;
      case "--rebase":
        mergeMethod = "rebase";
        break;
      case "--no-delete-branch":
        deleteBranch = false;
        break;
      case "--delete-branch":
        deleteBranch = true;
        break;
    }
  }
  const prNumber = prNumberStr ? parseInt(prNumberStr) : undefined;
  if (prNumberStr && isNaN(prNumber)) {
    output.error("PR number must be a valid integer");
    process.exit(1);
  }
  output.startSection("Merge Pull Request", "github");
  await stack.mergePullRequest(prNumber, mergeMethod, deleteBranch);
  output.endSection();
}
async function handleRebase(stack, args, options) {
  const [prNumber] = args;
  if (!prNumber) {
    output.error("Usage: rungs rebase <pr-number>");
    output.error("Rebase the stack after PR <pr-number> has been merged.");
    process.exit(1);
  }
  output.startSection("Rebase Stack", "stack");
  output.progress(`Rebasing stack after PR #${prNumber} merge...`);
  await stack.rebaseStack(parseInt(prNumber));
  output.success("Stack rebased successfully!");
  output.endSection();
}
async function handleConfig(config, args, options) {
  const [action, key, value] = args;
  output.startSection("Configuration", "config");
  if (action === "set" && key && value) {
    await config.set(key, value);
    output.success(`Set ${key} = ${value}`);
  } else if (action === "get" && key) {
    const val = await config.get(key);
    output.info(`${key} = ${val ?? "undefined"}`);
  } else if (action === "list" || !action) {
    const allConfig = await config.getAll();
    const configItems = Object.entries(allConfig).map(([k, v]) => ({
      label: k,
      value: v
    }));
    logSummary("Current Configuration", configItems);
  } else {
    output.error("Usage: rungs config [set <key> <value> | get <key> | list]");
    process.exit(1);
  }
  output.endSection();
}
if (import.meta.main) {
  main();
}
