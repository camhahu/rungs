#!/usr/bin/env bun
// @bun

// src/cli.ts
import { parseArgs } from "util";

// src/git-manager.ts
class GitManager {
  async getCurrentBranch() {
    const result = await Bun.$`git rev-parse --abbrev-ref HEAD`.text();
    return result.trim();
  }
  async isGitRepo() {
    try {
      await Bun.$`git rev-parse --git-dir`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async getStatus() {
    const currentBranch = await this.getCurrentBranch();
    const statusResult = await Bun.$`git status --porcelain`.text();
    const isClean = statusResult.trim() === "";
    let ahead = 0;
    let behind = 0;
    try {
      const aheadResult = await Bun.$`git rev-list --count HEAD..origin/${currentBranch}`.text();
      behind = parseInt(aheadResult.trim()) || 0;
      const behindResult = await Bun.$`git rev-list --count origin/${currentBranch}..HEAD`.text();
      ahead = parseInt(behindResult.trim()) || 0;
    } catch {}
    return {
      currentBranch,
      isClean,
      ahead,
      behind
    };
  }
  async getCommitsSince(baseBranch) {
    try {
      const result = await Bun.$`git log ${baseBranch}..HEAD '--pretty=format:%H|%s|%an|%ad' --date=iso`.text();
      if (!result.trim()) {
        return [];
      }
      return result.trim().split(`
`).map((line) => {
        const [hash, message, author, date] = line.split("|");
        return { hash, message, author, date };
      });
    } catch (error) {
      console.error(`Git command failed for ${baseBranch}:`);
      console.error(error);
      throw new Error(`Failed to get commits since ${baseBranch}: ${error}`);
    }
  }
  async fetchOrigin() {
    try {
      await Bun.$`git fetch origin`;
    } catch (error) {
      throw new Error(`Failed to fetch from origin: ${error}`);
    }
  }
  async rebaseOnto(targetBranch) {
    try {
      await Bun.$`git rebase origin/${targetBranch}`;
    } catch (error) {
      try {
        await Bun.$`git rebase --abort`;
      } catch {}
      throw new Error(`Failed to rebase onto ${targetBranch}. Please resolve conflicts manually.`);
    }
  }
  async createBranch(branchName, fromCommit) {
    try {
      if (fromCommit) {
        await Bun.$`git checkout -b ${branchName} ${fromCommit}`;
      } else {
        await Bun.$`git checkout -b ${branchName}`;
      }
    } catch (error) {
      throw new Error(`Failed to create branch ${branchName}: ${error}`);
    }
  }
  async checkoutBranch(branchName) {
    try {
      await Bun.$`git checkout ${branchName}`;
    } catch (error) {
      throw new Error(`Failed to checkout branch ${branchName}: ${error}`);
    }
  }
  async branchExists(branchName) {
    try {
      await Bun.$`git rev-parse --verify ${branchName}`;
      return true;
    } catch {
      return false;
    }
  }
  async pushBranch(branchName, force = false) {
    try {
      const forceFlag = force ? "--force-with-lease" : "";
      if (force) {
        await Bun.$`git push origin ${branchName} --force-with-lease`;
      } else {
        await Bun.$`git push origin ${branchName}`;
      }
    } catch (error) {
      throw new Error(`Failed to push branch ${branchName}: ${error}`);
    }
  }
  async getRemoteUrl() {
    try {
      const result = await Bun.$`git remote get-url origin`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get remote URL: ${error}`);
    }
  }
  async getCommitMessage(hash) {
    try {
      const result = await Bun.$`git log -1 --pretty=format:"%s" ${hash}`.text();
      return result.trim();
    } catch (error) {
      throw new Error(`Failed to get commit message for ${hash}: ${error}`);
    }
  }
  async getSyncStatus(remoteBranch) {
    try {
      await this.fetchOrigin();
      const remoteRef = `origin/${remoteBranch}`;
      try {
        await Bun.$`git rev-parse --verify ${remoteRef}`.quiet();
      } catch {
        return {
          status: "clean",
          aheadCount: 0,
          behindCount: 0,
          localCommits: [],
          remoteCommits: []
        };
      }
      const aheadResult = await Bun.$`git rev-list --count ${remoteRef}..HEAD`.text();
      const aheadCount = parseInt(aheadResult.trim()) || 0;
      const behindResult = await Bun.$`git rev-list --count HEAD..${remoteRef}`.text();
      const behindCount = parseInt(behindResult.trim()) || 0;
      let localCommits = [];
      let remoteCommits = [];
      if (aheadCount > 0) {
        const localResult = await Bun.$`git rev-list ${remoteRef}..HEAD`.text();
        localCommits = localResult.trim().split(`
`).filter(Boolean);
      }
      if (behindCount > 0) {
        const remoteResult = await Bun.$`git rev-list HEAD..${remoteRef}`.text();
        remoteCommits = remoteResult.trim().split(`
`).filter(Boolean);
      }
      let status;
      if (aheadCount === 0 && behindCount === 0) {
        status = "clean";
      } else if (aheadCount > 0 && behindCount === 0) {
        status = "ahead";
      } else if (aheadCount === 0 && behindCount > 0) {
        status = "behind";
      } else {
        status = "diverged";
      }
      return {
        status,
        aheadCount,
        behindCount,
        localCommits,
        remoteCommits
      };
    } catch (error) {
      throw new Error(`Failed to check sync status with ${remoteBranch}: ${error}`);
    }
  }
  async detectDuplicateCommits(remoteBranch) {
    try {
      const remoteRef = `origin/${remoteBranch}`;
      const localResult = await Bun.$`git log ${remoteRef}..HEAD --pretty=format:"%s"`.text();
      const localMessages = localResult.trim().split(`
`).filter(Boolean);
      if (localMessages.length === 0) {
        return { hasDuplicates: false, duplicateMessages: [] };
      }
      const remoteResult = await Bun.$`git log ${remoteRef} --pretty=format:"%s" -20`.text();
      const recentRemoteMessages = remoteResult.trim().split(`
`).filter(Boolean);
      const duplicates = localMessages.filter((msg) => recentRemoteMessages.some((remoteMsg) => remoteMsg.trim() === msg.trim()));
      return {
        hasDuplicates: duplicates.length > 0,
        duplicateMessages: duplicates
      };
    } catch (error) {
      throw new Error(`Failed to detect duplicate commits: ${error}`);
    }
  }
  generateBranchName(commits, userPrefix, strategy) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
    switch (strategy) {
      case "timestamp":
        return `${userPrefix}/${timestamp}`;
      case "sequential":
        return `${userPrefix}/stack-${Date.now()}`;
      case "commit-message":
      default:
        if (commits.length === 0) {
          return `${userPrefix}/empty-${timestamp}`;
        }
        const firstCommit = commits[0];
        const cleanMessage = firstCommit.message.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").slice(0, 50);
        const fullBranchName = `${userPrefix}/${cleanMessage}`;
        if (fullBranchName.length > 63) {
          const availableLength = 63 - userPrefix.length - 1;
          const truncatedMessage = cleanMessage.slice(0, availableLength);
          return `${userPrefix}/${truncatedMessage}`;
        }
        return fullBranchName;
    }
  }
  async pullLatestChanges(branch) {
    try {
      await Bun.$`git fetch origin`;
      const currentBranch = await this.getCurrentBranch();
      if (currentBranch !== branch) {
        await this.checkoutBranch(branch);
      }
      await Bun.$`git rebase origin/${branch}`;
    } catch (error) {
      try {
        await Bun.$`git rebase --abort`;
      } catch {}
      throw new Error(`Failed to pull latest changes for ${branch}: ${error}`);
    }
  }
}

// src/github-manager.ts
class GitHubManager {
  async isGitHubCLIAvailable() {
    try {
      await Bun.$`gh --version`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async isAuthenticated() {
    try {
      await Bun.$`gh auth status`.quiet();
      return true;
    } catch {
      return false;
    }
  }
  async getRepoInfo() {
    try {
      const result = await Bun.$`gh repo view --json owner,name`.text();
      const data = JSON.parse(result);
      return {
        owner: data.owner.login,
        repo: data.name
      };
    } catch (error) {
      throw new Error(`Failed to get repository info: ${error}`);
    }
  }
  async createPullRequest(title, body, head, base, draft = true) {
    try {
      const bodyFile = `/tmp/rungs-pr-body-${Date.now()}.txt`;
      await Bun.write(bodyFile, body);
      try {
        const args = ["gh", "pr", "create", "--title", title, "--body-file", bodyFile, "--head", head, "--base", base];
        if (draft) {
          args.push("--draft");
        }
        const prUrl = await Bun.$`${args}`.text();
        const prNumber = parseInt(prUrl.trim().split("/").pop() || "0");
        return {
          number: prNumber,
          title,
          body,
          url: prUrl.trim(),
          draft,
          head,
          base
        };
      } finally {
        try {
          await Bun.$`rm ${bodyFile}`.quiet();
        } catch {}
      }
    } catch (error) {
      let errorMessage = "Failed to create pull request";
      if (error.stderr) {
        errorMessage += `: ${error.stderr.toString().trim()}`;
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      } else {
        errorMessage += `: ${error}`;
      }
      if (error.stderr?.includes("remote ref does not exist") || head.length > 63) {
        errorMessage += `

Hint: Branch name may be too long. GitHub branch names must be 63 characters or less.`;
      }
      throw new Error(errorMessage);
    }
  }
  async updatePullRequest(prNumber, title, body) {
    try {
      const args = [];
      if (title) {
        args.push("--title", title);
      }
      if (body) {
        args.push("--body", body);
      }
      if (args.length > 0) {
        await Bun.$`gh pr edit ${prNumber} ${args}`;
      }
    } catch (error) {
      throw new Error(`Failed to update pull request #${prNumber}: ${error}`);
    }
  }
  async updatePullRequestBase(prNumber, newBase) {
    try {
      await Bun.$`gh pr edit ${prNumber} --base ${newBase}`;
    } catch (error) {
      throw new Error(`Failed to update pull request #${prNumber} base to ${newBase}: ${error}`);
    }
  }
  async mergePullRequest(prNumber, mergeMethod = "squash", deleteBranch = true) {
    try {
      const args = ["gh", "pr", "merge", prNumber.toString()];
      switch (mergeMethod) {
        case "squash":
          args.push("--squash");
          break;
        case "merge":
          args.push("--merge");
          break;
        case "rebase":
          args.push("--rebase");
          break;
      }
      if (deleteBranch) {
        args.push("--delete-branch");
      }
      await Bun.$`${args}`;
    } catch (error) {
      let errorMessage = `Failed to merge PR #${prNumber}`;
      if (error.stderr) {
        errorMessage += `: ${error.stderr.toString().trim()}`;
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      }
      throw new Error(errorMessage);
    }
  }
  async getPullRequest(branchName) {
    try {
      const result = await Bun.$`gh pr view ${branchName} --json number,title,body,url,isDraft,headRefName,baseRefName`.text();
      const data = JSON.parse(result);
      return {
        number: data.number,
        title: data.title,
        body: data.body,
        url: data.url,
        draft: data.isDraft,
        head: data.headRefName,
        base: data.baseRefName
      };
    } catch {
      return null;
    }
  }
  async getPullRequestByNumber(prNumber) {
    try {
      const result = await Bun.$`gh pr view ${prNumber} --json number,title,body,url,isDraft,headRefName,baseRefName`.text();
      const data = JSON.parse(result);
      return {
        number: data.number,
        title: data.title,
        body: data.body,
        url: data.url,
        draft: data.isDraft,
        head: data.headRefName,
        base: data.baseRefName
      };
    } catch {
      return null;
    }
  }
  async getPullRequestStatus(prNumber) {
    try {
      const result = await Bun.$`gh pr view ${prNumber} --json state`.text();
      const data = JSON.parse(result);
      return data.state.toLowerCase();
    } catch {
      return null;
    }
  }
  async listPullRequests(head) {
    try {
      let cmd = "gh pr list --json number,title,body,url,draft,headRefName,baseRefName";
      if (head) {
        cmd += ` --head ${head}`;
      }
      const result = await Bun.$`${cmd}`.text();
      const data = JSON.parse(result);
      return data.map((pr) => ({
        number: pr.number,
        title: pr.title,
        body: pr.body,
        url: pr.url,
        draft: pr.draft,
        head: pr.headRefName,
        base: pr.baseRefName
      }));
    } catch (error) {
      throw new Error(`Failed to list pull requests: ${error}`);
    }
  }
  async closePullRequest(prNumber) {
    try {
      await Bun.$`gh pr close ${prNumber}`;
    } catch (error) {
      throw new Error(`Failed to close pull request #${prNumber}: ${error}`);
    }
  }
  async publishPullRequest(prNumber) {
    try {
      await Bun.$`gh pr ready ${prNumber}`;
    } catch (error) {
      let errorMessage = `Failed to publish pull request #${prNumber}`;
      if (error.stderr) {
        const stderr = error.stderr.toString().trim();
        errorMessage += `: ${stderr}`;
        if (stderr.includes("not a draft")) {
          errorMessage += `

Hint: This PR is already published (not a draft).`;
        } else if (stderr.includes("not found")) {
          errorMessage += `

Hint: PR number may not exist or you may not have access to it.`;
        }
      } else if (error.message) {
        errorMessage += `: ${error.message}`;
      }
      throw new Error(errorMessage);
    }
  }
  generatePRTitle(commits) {
    if (commits.length === 0) {
      return "Empty stack";
    }
    if (commits.length === 1) {
      return commits[0].message;
    }
    return `${commits[0].message} (+${commits.length - 1} more)`;
  }
  generatePRBody(commits) {
    if (commits.length === 0) {
      return "Empty stack - no commits to include.";
    }
    if (commits.length === 1) {
      return `Single commit stack:

- ${commits[0].message}`;
    }
    const commitList = commits.map((commit) => `- ${commit.message}`).join(`
`);
    return `Stack of ${commits.length} commits:

${commitList}`;
  }
  async findPRsWithCommits(commitShas) {
    try {
      const result = await Bun.$`gh pr list --state open --json number,title,url,headRefName`.text();
      const openPRs = JSON.parse(result);
      const matchingPRs = [];
      for (const pr of openPRs) {
        try {
          const branchCommitsResult = await Bun.$`git log origin/${pr.headRefName} --pretty=format:"%H"`.text();
          const branchCommits = branchCommitsResult.trim().split(`
`).filter(Boolean);
          const hasMatchingCommits = commitShas.some((sha) => branchCommits.some((branchSha) => branchSha.startsWith(sha) || sha.startsWith(branchSha)));
          if (hasMatchingCommits) {
            matchingPRs.push({
              number: pr.number,
              url: pr.url,
              title: pr.title,
              status: "open"
            });
          }
        } catch (error) {
          continue;
        }
      }
      return matchingPRs;
    } catch (error) {
      throw new Error(`Failed to search for PRs with commits: ${error}`);
    }
  }
}

// src/config-manager.ts
import { join } from "path";
import { homedir } from "os";
var DEFAULT_CONFIG = {
  userPrefix: "dev",
  defaultBranch: "main",
  draftPRs: true,
  autoRebase: true,
  branchNaming: "commit-message"
};

class ConfigManager {
  configPath;
  constructor(customPath) {
    this.configPath = customPath || join(homedir(), ".config", "rungs", "config.json");
  }
  async ensureConfigDir() {
    const configDir = this.configPath.split("/").slice(0, -1).join("/");
    try {
      await Bun.$`mkdir -p ${configDir}`;
    } catch (error) {
      throw new Error(`Failed to create config directory: ${error}`);
    }
  }
  async getAll() {
    try {
      const file = Bun.file(this.configPath);
      if (!await file.exists()) {
        return DEFAULT_CONFIG;
      }
      const content = await file.text();
      const config = JSON.parse(content);
      return { ...DEFAULT_CONFIG, ...config };
    } catch (error) {
      console.warn(`Failed to read config file, using defaults: ${error}`);
      return DEFAULT_CONFIG;
    }
  }
  async get(key) {
    const config = await this.getAll();
    return config[key];
  }
  async set(key, value) {
    await this.ensureConfigDir();
    const config = await this.getAll();
    config[key] = value;
    try {
      await Bun.write(this.configPath, JSON.stringify(config, null, 2));
    } catch (error) {
      throw new Error(`Failed to write config file: ${error}`);
    }
  }
  async update(updates) {
    await this.ensureConfigDir();
    const config = await this.getAll();
    const newConfig = { ...config, ...updates };
    try {
      await Bun.write(this.configPath, JSON.stringify(newConfig, null, 2));
    } catch (error) {
      throw new Error(`Failed to update config file: ${error}`);
    }
  }
  async reset() {
    await this.ensureConfigDir();
    try {
      await Bun.write(this.configPath, JSON.stringify(DEFAULT_CONFIG, null, 2));
    } catch (error) {
      throw new Error(`Failed to reset config file: ${error}`);
    }
  }
}

// src/output-manager.ts
class OutputManager {
  indentLevel = 0;
  currentSection = null;
  config;
  static ICONS = {
    git: "\uD83D\uDD04",
    github: "\uD83D\uDCE4",
    stack: "\uD83D\uDCDA",
    config: "\u2699\uFE0F",
    general: "\uD83D\uDCBB",
    success: "\u2705",
    error: "\u274C",
    warning: "\u26A0\uFE0F",
    info: "\u2139\uFE0F",
    progress: "\uD83D\uDD04"
  };
  static COLORS = {
    reset: "\x1B[0m",
    bright: "\x1B[1m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    gray: "\x1B[90m"
  };
  constructor(config = {}) {
    this.config = {
      showTimestamps: false,
      useColors: true,
      verboseMode: false,
      ...config
    };
  }
  startSection(title, type = "general") {
    if (this.currentSection) {
      this.endSection();
    }
    const icon = OutputManager.ICONS[type];
    const separator = "\u2550".repeat(Math.max(20, title.length + 10));
    console.log();
    console.log(this.colorize(`${separator}`, "cyan"));
    console.log(this.colorize(`${icon} ${title.toUpperCase()}`, "bright"));
    console.log(this.colorize(`${separator}`, "cyan"));
    console.log();
    this.currentSection = title;
    this.indentLevel = 0;
  }
  endSection() {
    if (!this.currentSection)
      return;
    console.log();
    console.log(this.colorize("\u2550".repeat(30), "cyan"));
    console.log();
    this.currentSection = null;
    this.indentLevel = 0;
  }
  log(message, level = "info", indent = 0) {
    const icon = OutputManager.ICONS[level];
    const prefix = this.getPrefix(icon, level);
    const indentation = "  ".repeat(this.indentLevel + indent);
    const formattedMessage = `${indentation}${prefix} ${message}`;
    console.log(this.colorize(formattedMessage, this.getLevelColor(level)));
  }
  progress(message, indent = 0) {
    this.log(message, "progress", indent);
  }
  success(message, indent = 0) {
    this.log(message, "success", indent);
  }
  error(message, indent = 0) {
    this.log(message, "error", indent);
  }
  warning(message, indent = 0) {
    this.log(message, "warning", indent);
  }
  info(message, indent = 0) {
    this.log(message, "info", indent);
  }
  startGroup(title, type = "general") {
    const icon = OutputManager.ICONS[type];
    const indentation = "  ".repeat(this.indentLevel);
    console.log();
    console.log(this.colorize(`${indentation}${icon} ${title}:`, "bright"));
    this.indentLevel++;
  }
  endGroup() {
    if (this.indentLevel > 0) {
      this.indentLevel--;
    }
    console.log();
  }
  logList(items, title, level = "info") {
    if (title) {
      this.log(title, level);
    }
    items.forEach((item) => {
      const indentation = "  ".repeat(this.indentLevel + 1);
      console.log(this.colorize(`${indentation}- ${item}`, this.getLevelColor(level)));
    });
  }
  logCommand(command) {
    if (this.config.verboseMode) {
      const indentation = "  ".repeat(this.indentLevel);
      console.log(this.colorize(`${indentation}$ ${command}`, "gray"));
    }
  }
  summary(title, items) {
    console.log();
    console.log(this.colorize(`\uD83D\uDCCB ${title}:`, "bright"));
    const maxLabelLength = Math.max(...items.map((item) => item.label.length));
    items.forEach((item) => {
      const paddedLabel = item.label.padEnd(maxLabelLength);
      const indentation = "  ".repeat(this.indentLevel + 1);
      console.log(this.colorize(`${indentation}${paddedLabel}: ${item.value}`, "info"));
    });
    console.log();
  }
  separator(char = "\u2500", length = 40) {
    const indentation = "  ".repeat(this.indentLevel);
    console.log(this.colorize(`${indentation}${char.repeat(length)}`, "gray"));
  }
  setVerbose(verbose) {
    this.config.verboseMode = verbose;
  }
  getPrefix(icon, level) {
    if (this.config.showTimestamps) {
      const timestamp = new Date().toLocaleTimeString();
      return `[${timestamp}] ${icon}`;
    }
    return icon;
  }
  getLevelColor(level) {
    switch (level) {
      case "success":
        return "green";
      case "error":
        return "red";
      case "warning":
        return "yellow";
      case "progress":
        return "cyan";
      case "info":
      default:
        return "reset";
    }
  }
  colorize(text, color) {
    if (!this.config.useColors) {
      return text;
    }
    const colorCode = OutputManager.COLORS[color];
    if (!colorCode) {
      return text;
    }
    return `${colorCode}${text}${OutputManager.COLORS.reset}`;
  }
}
var output = new OutputManager;
function logProgress(message, indent = 0) {
  output.progress(message, indent);
}
function logSuccess(message, indent = 0) {
  output.success(message, indent);
}
function logWarning(message, indent = 0) {
  output.warning(message, indent);
}
function logInfo(message, indent = 0) {
  output.info(message, indent);
}
function startGroup(title, type = "general") {
  output.startGroup(title, type);
}
function endGroup() {
  output.endGroup();
}
function logSummary(title, items) {
  output.summary(title, items);
}
function setVerbose(verbose) {
  output.setVerbose(verbose);
}

// src/stack-manager.ts
class StackManager {
  config;
  git;
  github;
  constructor(config, git, github) {
    this.config = config;
    this.git = git;
    this.github = github;
  }
  async ensurePrerequisites() {
    if (!await this.git.isGitRepo()) {
      throw new Error("Not in a git repository. Run 'git init' to initialize a repository.");
    }
    if (!await this.github.isGitHubCLIAvailable()) {
      throw new Error("GitHub CLI (gh) is not installed or not in PATH. Install from https://cli.github.com/");
    }
    if (!await this.github.isAuthenticated()) {
      throw new Error("Not authenticated with GitHub CLI. Run 'gh auth login' to authenticate.");
    }
  }
  async getCurrentStack() {
    startGroup("Discovering Stack from GitHub", "github");
    try {
      const config = await this.config.getAll();
      logProgress("Fetching open PRs...");
      const result = await Bun.$`gh pr list --author @me --state open --json number,title,url,headRefName,baseRefName`.text();
      const allPRs = JSON.parse(result);
      const stackPRs = allPRs.filter((pr) => pr.headRefName.startsWith(config.userPrefix + "/"));
      logInfo(`Found ${stackPRs.length} stack PRs out of ${allPRs.length} total open PRs`, 1);
      if (stackPRs.length === 0) {
        endGroup();
        return { prs: [], totalCommits: 0 };
      }
      logProgress("Building stack order from base chains...");
      const orderedPRs = this.buildStackOrder(stackPRs, config.defaultBranch);
      logProgress("Validating and auto-fixing broken chains...");
      const fixedPRs = await this.autoFixBrokenChains(orderedPRs, config.defaultBranch);
      const stackState = {
        prs: fixedPRs.map((pr) => ({
          number: pr.number,
          branch: pr.headRefName,
          title: pr.title,
          url: pr.url,
          base: pr.baseRefName,
          head: pr.headRefName
        })),
        totalCommits: 0,
        lastBranch: fixedPRs.length > 0 ? fixedPRs[fixedPRs.length - 1].headRefName : undefined
      };
      logSuccess(`Stack discovered: ${fixedPRs.length} PRs in order`);
      if (fixedPRs.length > 0) {
        const stackOrder = fixedPRs.map((pr, i) => `${i + 1}. PR #${pr.number}: ${pr.headRefName} <- ${pr.baseRefName}`);
        output.logList(stackOrder, "Stack Order:", "info");
      }
      endGroup();
      return stackState;
    } catch (error) {
      endGroup();
      throw new Error(`Failed to discover stack from GitHub: ${error}`);
    }
  }
  async getNewCommits() {
    startGroup("Finding New Commits", "git");
    try {
      const config = await this.config.getAll();
      const currentStack = await this.getCurrentStack();
      logProgress("Determining base reference...");
      const exclusions = [`origin/${config.defaultBranch}`];
      for (const pr of currentStack.prs) {
        exclusions.push(`origin/${pr.branch}`);
      }
      logInfo(`Excluding commits from: ${exclusions.join(", ")}`, 1);
      logProgress("Scanning for new commits...");
      let newCommits = [];
      for (const exclusion of exclusions) {
        try {
          await Bun.$`git rev-parse --verify ${exclusion}`.quiet();
          const commitsFromThisRef = await this.git.getCommitsSince(exclusion);
          if (commitsFromThisRef.length > 0) {
            if (newCommits.length === 0 || commitsFromThisRef.length < newCommits.length) {
              newCommits = commitsFromThisRef;
              logInfo(`Using ${exclusion} as base (${commitsFromThisRef.length} new commits)`, 1);
            }
          }
        } catch {
          continue;
        }
      }
      if (newCommits.length === 0) {
        try {
          newCommits = await this.git.getCommitsSince(`origin/${config.defaultBranch}`);
          logInfo(`Falling back to origin/${config.defaultBranch}`, 1);
        } catch {
          try {
            const rootCommit = await Bun.$`git rev-list --max-parents=0 HEAD`.text();
            const baseRef = rootCommit.trim().split(`
`)[0];
            newCommits = await this.git.getCommitsSince(baseRef);
            logInfo(`Using root commit as base`, 1);
          } catch {
            newCommits = [];
          }
        }
      }
      logSuccess(`Found ${newCommits.length} new commits`);
      if (newCommits.length > 0) {
        const commitList = newCommits.map((c) => `${c.hash.slice(0, 7)}: ${c.message}`);
        output.logList(commitList, "New commits:", "info");
      }
      endGroup();
      return newCommits;
    } catch (error) {
      endGroup();
      throw new Error(`Failed to find new commits: ${error}`);
    }
  }
  buildStackOrder(prs, defaultBranch) {
    const orderedPRs = [];
    const remaining = [...prs];
    let currentBase = defaultBranch;
    while (remaining.length > 0) {
      const nextPR = remaining.find((pr) => pr.baseRefName === currentBase);
      if (!nextPR) {
        if (remaining.length > 0) {
          logWarning(`Broken chain detected: ${remaining.length} PRs don't follow proper base chain`, 1);
          orderedPRs.push(...remaining);
        }
        break;
      }
      orderedPRs.push(nextPR);
      remaining.splice(remaining.indexOf(nextPR), 1);
      currentBase = nextPR.headRefName;
    }
    return orderedPRs;
  }
  async autoFixBrokenChains(prs, defaultBranch) {
    const fixedPRs = [...prs];
    const needsFixing = [];
    for (let i = 0;i < fixedPRs.length; i++) {
      const pr = fixedPRs[i];
      const expectedBase = i === 0 ? defaultBranch : fixedPRs[i - 1].headRefName;
      if (pr.baseRefName !== expectedBase) {
        needsFixing.push({
          prNumber: pr.number,
          currentBase: pr.baseRefName,
          correctBase: expectedBase
        });
        fixedPRs[i] = { ...pr, baseRefName: expectedBase };
      }
    }
    if (needsFixing.length > 0) {
      startGroup(`Auto-fixing ${needsFixing.length} broken base chains`, "github");
      for (const fix of needsFixing) {
        try {
          logProgress(`Updating PR #${fix.prNumber}: ${fix.currentBase} -> ${fix.correctBase}`, 1);
          await this.github.updatePullRequestBase(fix.prNumber, fix.correctBase);
          logSuccess(`Fixed PR #${fix.prNumber} base`, 1);
        } catch (error) {
          logWarning(`Could not fix PR #${fix.prNumber} base: ${error}`, 1);
        }
      }
      endGroup();
    }
    return fixedPRs;
  }
  async pushStack(autoPublish = false, force = false) {
    await this.ensurePrerequisites();
    const config = await this.config.getAll();
    const currentBranch = await this.git.getCurrentBranch();
    if (currentBranch !== config.defaultBranch) {
      throw new Error(`Must be on ${config.defaultBranch} branch to push stack. Currently on ${currentBranch}.`);
    }
    const status = await this.git.getStatus();
    if (!status.isClean) {
      throw new Error("Working directory is not clean. Please commit or stash changes.");
    }
    if (!force) {
      await this.validateSyncStatus(config.defaultBranch);
    }
    if (config.autoRebase) {
      startGroup("Fetching Latest Changes", "git");
      logProgress("Fetching from origin...");
      await this.git.fetchOrigin();
      logSuccess("Fetched latest changes");
      if (status.behind > 0) {
        logProgress(`Rebasing ${status.behind} commits...`);
        await this.git.rebaseOnto(config.defaultBranch);
        logSuccess("Rebase completed");
      }
      endGroup();
    }
    const newCommits = await this.getNewCommits();
    if (newCommits.length === 0) {
      logInfo("No new commits to process.");
      return;
    }
    startGroup("Processing Commits", "git");
    logInfo(`Found ${newCommits.length} new commits to process.`);
    const commitList = newCommits.map((c) => `${c.hash.slice(0, 7)}: ${c.message}`);
    output.logList(commitList, "Commits to process:", "info");
    endGroup();
    startGroup("Checking for Duplicate PRs", "github");
    logProgress("Searching for existing PRs with these commits...");
    const commitShas = newCommits.map((c) => c.hash);
    const existingPRs = await this.github.findPRsWithCommits(commitShas);
    if (existingPRs.length > 0) {
      const existingPR = existingPRs[0];
      endGroup();
      logWarning("\u274C These commits already exist in an existing PR");
      logInfo(`PR #${existingPR.number}: ${existingPR.title}`);
      logInfo(`URL: ${existingPR.url}`);
      logInfo(`Status: ${existingPR.status}`);
      logInfo("");
      logInfo("No new PR created. You can:");
      logInfo(`  - Update PR #${existingPR.number} if needed`);
      logInfo("  - Run 'rungs status' to see current PRs");
      return;
    }
    logSuccess("No duplicate PRs found");
    endGroup();
    const branchName = this.git.generateBranchName(newCommits, config.userPrefix, config.branchNaming);
    if (await this.git.branchExists(branchName)) {
      throw new Error(`Branch ${branchName} already exists. Please delete it or use a different naming strategy.`);
    }
    startGroup("Creating Branch", "git");
    logProgress(`Creating branch: ${branchName}`);
    await this.git.createBranch(branchName);
    logProgress("Pushing branch to remote...");
    await this.git.pushBranch(branchName);
    logSuccess("Branch created and pushed");
    endGroup();
    startGroup("Creating Pull Request", "github");
    const prTitle = this.github.generatePRTitle(newCommits);
    const prBody = this.github.generatePRBody(newCommits);
    const currentStack = await this.getCurrentStack();
    const baseBranch = currentStack.lastBranch || config.defaultBranch;
    logProgress(`Creating PR: "${prTitle}"`);
    logInfo(`Base branch: ${baseBranch}`, 1);
    const isDraft = autoPublish ? false : config.draftPRs;
    logInfo(`Draft mode: ${isDraft ? "Yes" : "No (published)"}`, 1);
    const pr = await this.github.createPullRequest(prTitle, prBody, branchName, baseBranch, isDraft);
    logSuccess(`Created pull request: ${pr.url}`);
    endGroup();
    startGroup("Finalizing", "stack");
    logProgress("Switching back to main branch...");
    await this.git.checkoutBranch(config.defaultBranch);
    logSuccess("Returned to main branch");
    endGroup();
    logSummary("Stack Created Successfully", [
      { label: "Branch", value: branchName },
      { label: "Pull Request", value: `#${pr.number}` },
      { label: "URL", value: pr.url }
    ]);
    logInfo(`You can now continue working on ${config.defaultBranch} and run 'rungs push' again for additional commits.`);
  }
  async getStatus() {
    await this.ensurePrerequisites();
    const config = await this.config.getAll();
    const gitStatus = await this.git.getStatus();
    const currentStack = await this.getCurrentStack();
    const newCommits = await this.getNewCommits();
    let statusMessage = `
Current Status:
- Branch: ${gitStatus.currentBranch}
- Clean: ${gitStatus.isClean ? "Yes" : "No"}
- Ahead: ${gitStatus.ahead} commits
- Behind: ${gitStatus.behind} commits

Stack Status (from GitHub):
- Active PRs: ${currentStack.prs.length}
- New commits ready: ${newCommits.length}
`;
    if (currentStack.prs.length > 0) {
      statusMessage += `
Active PRs (in stack order):
${currentStack.prs.map((pr, i) => `  ${i + 1}. #${pr.number}: ${pr.branch} <- ${pr.base}`).join(`
`)}`;
    }
    if (newCommits.length > 0) {
      statusMessage += `
New Commits (ready to push):
${newCommits.map((c) => `  - ${c.hash.slice(0, 7)}: ${c.message}`).join(`
`)}`;
    }
    return statusMessage;
  }
  async mergePullRequest(prNumber, mergeMethod = "squash", deleteBranch = true) {
    await this.ensurePrerequisites();
    const currentStack = await this.getCurrentStack();
    if (!prNumber) {
      if (currentStack.prs.length === 0) {
        throw new Error("No PRs found in current stack");
      }
      prNumber = currentStack.prs[currentStack.prs.length - 1].number;
    }
    const prBeingMerged = currentStack.prs.find((pr) => pr.number === prNumber);
    if (prBeingMerged && deleteBranch) {
      const dependentPRs = currentStack.prs.filter((pr) => pr.baseRefName === prBeingMerged.headRefName && pr.number !== prNumber);
      if (dependentPRs.length > 0) {
        startGroup(`Pre-merge stack updates`, "github");
        logInfo(`Found ${dependentPRs.length} dependent PRs that need base updates before merge`);
        for (const dependentPR of dependentPRs) {
          const prIndex = currentStack.prs.findIndex((pr) => pr.number === dependentPR.number);
          const newBase = prIndex > 0 ? currentStack.prs[prIndex - 1].headRefName : await this.config.get("defaultBranch");
          try {
            logProgress(`Updating PR #${dependentPR.number}: ${dependentPR.baseRefName} -> ${newBase}`, 1);
            await this.github.updatePullRequestBase(dependentPR.number, newBase);
            logSuccess(`Pre-updated PR #${dependentPR.number} base to avoid auto-closure`, 1);
          } catch (error) {
            logWarning(`Could not pre-update PR #${dependentPR.number} base: ${error}`, 1);
          }
        }
        endGroup();
      }
    }
    logInfo(`Merging PR #${prNumber} using ${mergeMethod} merge...`);
    await this.github.mergePullRequest(prNumber, mergeMethod, deleteBranch);
    logSuccess(`\u2705 Successfully merged PR #${prNumber}`);
    logInfo("\uD83D\uDD04 Updating local main with latest changes...");
    try {
      const config = await this.config.getAll();
      logInfo("  \uD83D\uDD04 Fetching from remote...");
      logInfo("  \uD83D\uDD04 Rebasing local changes...");
      await this.git.pullLatestChanges(config.defaultBranch);
      logInfo("  \u2705 Local main is now up to date");
    } catch (error) {
      const config = await this.config.getAll();
      logWarning(`  \u26A0\uFE0F Warning: Could not update local ${config.defaultBranch}: ${error}`);
    }
    logInfo("Updating stack state from GitHub...");
    await this.getCurrentStack();
    logInfo("Stack state updated successfully!");
  }
  async publishPullRequest(prNumber) {
    await this.ensurePrerequisites();
    if (!prNumber) {
      const currentStack = await this.getCurrentStack();
      if (currentStack.prs.length === 0) {
        throw new Error("No PRs found in current stack");
      }
      prNumber = currentStack.prs[currentStack.prs.length - 1].number;
    } else {
      const currentStack = await this.getCurrentStack();
      const isInStack = currentStack.prs.some((pr) => pr.number === prNumber);
      if (!isInStack) {
        console.warn(`Warning: PR #${prNumber} is not tracked in current stack, but attempting to publish anyway...`);
      }
    }
    await this.github.publishPullRequest(prNumber);
  }
  async validateSyncStatus(defaultBranch) {
    startGroup("Validating Sync Status", "git");
    try {
      logProgress("Checking sync status with remote...");
      const syncResult = await this.git.getSyncStatus(defaultBranch);
      if (syncResult.status === "clean") {
        logSuccess("Local branch is in sync with remote");
        endGroup();
        return;
      }
      const duplicateCheck = await this.git.detectDuplicateCommits(defaultBranch);
      let errorMessage = `\u274C Cannot create PR: Local branch is out of sync with remote

`;
      switch (syncResult.status) {
        case "ahead":
          if (duplicateCheck.hasDuplicates) {
            errorMessage += `Your local ${defaultBranch} has ${syncResult.aheadCount} commits that may already be merged into remote.
`;
            errorMessage += `Duplicate commit messages found:
${duplicateCheck.duplicateMessages.map((msg) => `  - ${msg}`).join(`
`)}

`;
            errorMessage += `This would create a PR with merge conflicts.

`;
            errorMessage += `To resolve:
`;
            errorMessage += `  git reset --hard origin/${defaultBranch}    # Reset to remote state
`;
            errorMessage += `  git cherry-pick <specific-commits>         # Re-apply only new commits

`;
            errorMessage += `Or:
`;
            errorMessage += `  git rebase origin/${defaultBranch}         # Rebase on top of remote

`;
          } else {
            logInfo(`Local is ${syncResult.aheadCount} commits ahead with new changes - ready to create PR`);
            endGroup();
            return;
          }
          break;
        case "behind":
          errorMessage += `Your local ${defaultBranch} is ${syncResult.behindCount} commits behind remote.
`;
          errorMessage += `To resolve:
`;
          errorMessage += `  git pull origin ${defaultBranch}            # Pull latest changes

`;
          break;
        case "diverged":
          errorMessage += `Your local ${defaultBranch} has diverged from remote:
`;
          errorMessage += `  - ${syncResult.aheadCount} commits ahead
`;
          errorMessage += `  - ${syncResult.behindCount} commits behind

`;
          errorMessage += `To resolve:
`;
          errorMessage += `  git rebase origin/${defaultBranch}          # Rebase your changes on top
`;
          errorMessage += `Or:
`;
          errorMessage += `  git reset --hard origin/${defaultBranch}    # Reset to remote (loses local changes)

`;
          break;
      }
      errorMessage += "Use --force to create PR anyway (not recommended)";
      endGroup();
      throw new Error(errorMessage);
    } catch (error) {
      endGroup();
      if (error instanceof Error && error.message.includes("Cannot create PR")) {
        throw error;
      }
      throw new Error(`Failed to validate sync status: ${error}`);
    }
  }
}

// src/cli.ts
var COMMANDS = {
  stack: "Create a new stack or add commits to existing stack",
  status: "Show current stack status",
  merge: "Merge PRs and update stack state",
  publish: "Mark PR as ready for review (remove draft status)",
  config: "Manage configuration",
  help: "Show help information"
};
var HIDDEN_COMMANDS = {
  rebase: "Rebase stack when PRs are merged"
};
async function main() {
  try {
    const { positionals, values } = parseArgs({
      args: process.argv.slice(2),
      options: {
        help: { type: "boolean", short: "h" },
        config: { type: "string", short: "c" },
        verbose: { type: "boolean", short: "v" },
        "auto-publish": { type: "boolean" },
        force: { type: "boolean", short: "f" }
      },
      allowPositionals: true
    });
    const options = {
      ...values,
      autoPublish: values["auto-publish"]
    };
    const [command, ...args] = positionals;
    if (options.help || !command || command === "help") {
      showHelp();
      return;
    }
    if (!isValidCommand(command)) {
      output.error(`Unknown command: ${command}`);
      output.info("Run 'rungs help' for available commands.");
      process.exit(1);
    }
    if (options.verbose) {
      setVerbose(true);
    }
    const config = new ConfigManager(options.config);
    const git = new GitManager;
    const github = new GitHubManager;
    const stack = new StackManager(config, git, github);
    switch (command) {
      case "stack":
        await handlePush(stack, args, options);
        break;
      case "status":
        await handleStatus(stack, options);
        break;
      case "merge":
        await handleMerge(stack, args, options);
        break;
      case "publish":
        await handlePublish(stack, args, options);
        break;
      case "rebase":
        await handleRebase(stack, args, options);
        break;
      case "config":
        await handleConfig(config, args, options);
        break;
      default:
        output.error(`Command not implemented: ${command}`);
        process.exit(1);
    }
  } catch (error) {
    output.error(error instanceof Error ? error.message : String(error));
    if (process.argv.includes("--verbose") || process.argv.includes("-v")) {
      console.error(error);
    }
    process.exit(1);
  }
}
function isValidCommand(cmd) {
  return cmd in COMMANDS || cmd in HIDDEN_COMMANDS;
}
function showHelp() {
  console.log(`
rungs - CLI tool for managing stacked diffs with Git and GitHub

USAGE:
  rungs <command> [options]

COMMANDS:
${Object.entries(COMMANDS).map(([cmd, desc]) => `  ${cmd.padEnd(12)} ${desc}`).join(`
`)}

OPTIONS:
  -h, --help         Show help information
  -c, --config PATH  Specify config file path
  -v, --verbose      Enable verbose output
  -f, --force        Force operation, bypassing safety checks
      --auto-publish Create PRs as published instead of draft

EXAMPLES:
  rungs stack                      # Create/update stack with current commits
  rungs stack --auto-publish       # Create PRs as published instead of draft
  rungs stack --force              # Create PRs even if local is out of sync
  rungs publish 123                # Mark PR #123 as ready for review
  rungs publish                    # Mark top PR in stack as ready for review
  rungs status                     # Show current stack status
  rungs config set name john       # Set user name prefix for branches
  rungs help                       # Show this help

For more information, visit: https://github.com/camhahu/rungs
`);
}
async function handlePush(stack, args, options) {
  output.startSection("Push Stack Operation", "stack");
  await stack.pushStack(options.autoPublish, options.force);
  output.success("Stack operation completed successfully!");
  output.endSection();
}
async function handleStatus(stack, options) {
  output.startSection("Stack Status", "stack");
  const status = await stack.getStatus();
  console.log(status);
  output.endSection();
}
async function handlePublish(stack, args, options) {
  const [prNumberStr] = args;
  output.startSection("Publish Pull Request", "github");
  if (prNumberStr) {
    const prNumber = parseInt(prNumberStr);
    if (isNaN(prNumber)) {
      output.error("PR number must be a valid integer");
      process.exit(1);
    }
    output.progress(`Publishing PR #${prNumber}...`);
    await stack.publishPullRequest(prNumber);
    output.success(`Successfully published PR #${prNumber}`);
  } else {
    output.progress("Publishing top PR in stack...");
    await stack.publishPullRequest();
    output.success("Successfully published top PR in stack");
  }
  output.endSection();
}
async function handleMerge(stack, args, options) {
  const [prNumberStr, ...flags] = args;
  let mergeMethod = "squash";
  let deleteBranch = true;
  for (const flag of flags) {
    switch (flag) {
      case "--squash":
        mergeMethod = "squash";
        break;
      case "--merge":
        mergeMethod = "merge";
        break;
      case "--rebase":
        mergeMethod = "rebase";
        break;
      case "--no-delete-branch":
        deleteBranch = false;
        break;
      case "--delete-branch":
        deleteBranch = true;
        break;
    }
  }
  const prNumber = prNumberStr ? parseInt(prNumberStr) : undefined;
  if (prNumberStr && isNaN(prNumber)) {
    output.error("PR number must be a valid integer");
    process.exit(1);
  }
  output.startSection("Merge Pull Request", "github");
  await stack.mergePullRequest(prNumber, mergeMethod, deleteBranch);
  output.endSection();
}
async function handleRebase(stack, args, options) {
  output.startSection("Rebase Stack", "stack");
  output.info("The new GitHub-first stack manager automatically fixes broken chains.");
  output.info("Stack bases are updated automatically when you run 'rungs status' or 'rungs stack'.");
  output.info("Manual rebase is no longer needed!");
  output.endSection();
}
async function handleConfig(config, args, options) {
  const [action, key, value] = args;
  output.startSection("Configuration", "config");
  if (action === "set" && key && value) {
    await config.set(key, value);
    output.success(`Set ${key} = ${value}`);
  } else if (action === "get" && key) {
    const val = await config.get(key);
    output.info(`${key} = ${val ?? "undefined"}`);
  } else if (action === "list" || !action) {
    const allConfig = await config.getAll();
    const configItems = Object.entries(allConfig).map(([k, v]) => ({
      label: k,
      value: v
    }));
    logSummary("Current Configuration", configItems);
  } else {
    output.error("Usage: rungs config [set <key> <value> | get <key> | list]");
    process.exit(1);
  }
  output.endSection();
}
if (import.meta.main) {
  main();
}
